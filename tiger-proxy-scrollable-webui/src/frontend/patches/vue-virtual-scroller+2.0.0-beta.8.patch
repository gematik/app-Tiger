diff --git a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js
index 8c5962e..dc70f89 100644
--- a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js
+++ b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js
@@ -342,7 +342,7 @@ var script$2 = {
       unusedPool.push(view);
       if (!fake) {
         view.nr.used = false;
-        view.position = -9999;
+        view.position = -999999;
       }
     },
 
diff --git a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js.map b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js.map
index 12e877e..fab518e 100644
--- a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js.map
+++ b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.esm.js.map
@@ -1 +1 @@
-{"version":3,"file":"vue-virtual-scroller.esm.js","sources":["../src/config.js","../src/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/mixins/IdState.js","../src/index.js"],"sourcesContent":["export default {\n  itemsLimit: 1000,\n}\n","// Fork of https://github.com/olahol/scrollparent.js to be able to build with Rollup\n\nconst regex = /(auto|scroll)/\n\nfunction parents (node, ps) {\n  if (node.parentNode === null) { return ps }\n\n  return parents(node.parentNode, ps.concat([node]))\n}\n\nconst style = function (node, prop) {\n  return getComputedStyle(node, null).getPropertyValue(prop)\n}\n\nconst overflow = function (node) {\n  return style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x')\n}\n\nconst scroll = function (node) {\n  return regex.test(overflow(node))\n}\n\nexport function getScrollParent (node) {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return\n  }\n\n  const ps = parents(node.parentNode, [])\n\n  for (let i = 0; i < ps.length; i += 1) {\n    if (scroll(ps[i])) {\n      return ps[i]\n    }\n  }\n\n  return document.scrollingElement || document.documentElement\n}\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<script>\nimport { h } from 'vue'\n\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  emits: [\n    'resize',\n  ],\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField]\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)\n    },\n\n    size () {\n      return this.vscrollData.sizes[this.id] || 0\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id (value, oldValue) {\n      this.$el.$_vs_id = this.id\n      if (!this.size) {\n        this.onDataUpdate()\n      }\n\n      if (this.$_sizeObserved) {\n        // In case the old item had the same size, it won't trigger the ResizeObserver\n        // since we are reusing the same DOM node\n        const oldSize = this.vscrollData.sizes[oldValue]\n        const size = this.vscrollData.sizes[value]\n        if (oldSize != null && oldSize !== size) {\n          this.applySize(oldSize)\n        }\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++\n            this.vscrollParent.$_undefinedMap[this.id] = true\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--\n            this.vscrollParent.$_undefinedMap[this.id] = false\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize()\n        } else {\n          this.unobserveSize()\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize()\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return\n\n    this.$_forceNextVScrollUpdate = null\n    this.updateWatchData()\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\n      }\n\n      this.vscrollParent.$_events.on('vscroll:update', this.onVscrollUpdate)\n    }\n  },\n\n  mounted () {\n    if (this.finalActive) {\n      this.updateSize()\n      this.observeSize()\n    }\n  },\n\n  beforeUnmount () {\n    this.vscrollParent.$_events.off('vscroll:update', this.onVscrollUpdate)\n    this.unobserveSize()\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id\n          this.$_forceNextVScrollUpdate = null\n          this.$_pendingVScrollUpdate = null\n          this.computeSize(this.id)\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate()\n        }, {\n          deep: true,\n        })\n      } else if (this.$_watchData) {\n        this.$_watchData()\n        this.$_watchData = null\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize()\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize()\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth\n          const height = this.$el.offsetHeight\n          this.applyWidthHeight(width, height)\n        }\n        this.$_pendingSizeUpdate = null\n      })\n    },\n\n    applyWidthHeight (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width)\n      if (size && this.size !== size) {\n        this.applySize(size)\n      }\n    },\n\n    applySize (size) {\n      if (this.vscrollParent.$_undefinedMap[this.id]) {\n        this.vscrollParent.$_undefinedSizes--\n        this.vscrollParent.$_undefinedMap[this.id] = undefined\n      }\n      this.vscrollData.sizes[this.id] = size\n      if (this.emitResize) this.$emit('resize', this.id)\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return\n      if (this.$_sizeObserved) return\n      this.vscrollResizeObserver.observe(this.$el)\n      this.$el.$_vs_id = this.id\n      this.$el.$_vs_onResize = this.onResize\n      this.$_sizeObserved = true\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return\n      if (!this.$_sizeObserved) return\n      this.vscrollResizeObserver.unobserve(this.$el)\n      this.$el.$_vs_onResize = undefined\n      this.$_sizeObserved = false\n    },\n\n    onResize (id, width, height) {\n      if (this.id === id) {\n        this.applyWidthHeight(width, height)\n      }\n    },\n  },\n\n  render () {\n    return h(this.tag, this.$slots.default())\n  },\n}\n</script>\n","import { reactive } from 'vue'\n\nexport default function ({\n  idProp = vm => vm.item.id,\n} = {}) {\n  const store = reactive({})\n\n  // @vue/component\n  return {\n    data () {\n      return {\n        idState: null,\n      }\n    },\n\n    created () {\n      this.$_id = null\n      if (typeof idProp === 'function') {\n        this.$_getId = () => idProp.call(this, this)\n      } else {\n        this.$_getId = () => this[idProp]\n      }\n      this.$watch(this.$_getId, {\n        handler (value) {\n          this.$nextTick(() => {\n            this.$_id = value\n          })\n        },\n        immediate: true,\n      })\n      this.$_updateIdState()\n    },\n\n    beforeUpdate () {\n      this.$_updateIdState()\n    },\n\n    methods: {\n      /**\n       * Initialize an idState\n       * @param {number|string} id Unique id for the data\n       */\n      $_idStateInit (id) {\n        const factory = this.$options.idState\n        if (typeof factory === 'function') {\n          const data = factory.call(this, this)\n          store[id] = data\n          this.$_id = id\n          return data\n        } else {\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\n        }\n      },\n\n      /**\n       * Ensure idState is created and up-to-date\n       */\n      $_updateIdState () {\n        const id = this.$_getId()\n        if (id == null) {\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\n        }\n        if (id !== this.$_id) {\n          if (!store[id]) {\n            this.$_idStateInit(id)\n          }\n          this.idState = store[id]\n        }\n      },\n    },\n  }\n}\n","import config from './config'\n\nimport RecycleScroller from './components/RecycleScroller.vue'\nimport DynamicScroller from './components/DynamicScroller.vue'\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\n\nexport { default as IdState } from './mixins/IdState'\n\nexport {\n  RecycleScroller,\n  DynamicScroller,\n  DynamicScrollerItem,\n}\n\nfunction registerComponents (app, prefix) {\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\n}\n\nconst plugin = {\n  // eslint-disable-next-line no-undef\n  version: VERSION,\n  install (app, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: '',\n    }, options)\n\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key]\n      }\n    }\n\n    if (finalOptions.installComponents) {\n      registerComponents(app, finalOptions.componentsPrefix)\n    }\n  },\n}\n\nexport default plugin\n"],"names":["itemsLimit","regex","parents","node","ps","parentNode","concat","style","prop","getComputedStyle","getPropertyValue","overflow","scroll","test","getScrollParent","HTMLElement","SVGElement","i","length","document","scrollingElement","documentElement","props","items","type","Array","required","keyField","String","default","direction","validator","value","includes","listTag","itemTag","simpleArray","supportsPassive","window","opts","Object","defineProperty","get","addEventListener","e","ResizeObserver","_createElementBlock","_openBlock","_renderSlot","_createBlock","_resolveDynamicComponent","_normalizeStyle","_normalizeClass","_Fragment","_renderList","_mergeProps","_toHandlers","_createVNode","RecycleScroller","_normalizeProps","_guardReactiveProps","idProp","vm","item","id","store","reactive","data","idState","created","$_id","$_getId","call","$watch","handler","$nextTick","immediate","$_updateIdState","beforeUpdate","methods","$_idStateInit","factory","$options","Error","console","warn","registerComponents","app","prefix","component","DynamicScroller","DynamicScrollerItem","plugin","version","VERSION","install","options","finalOptions","assign","installComponents","componentsPrefix","key","config"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"vue-virtual-scroller.esm.js","sources":["../src/config.js","../src/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/mixins/IdState.js","../src/index.js"],"sourcesContent":["export default {\n  itemsLimit: 1000,\n}\n","// Fork of https://github.com/olahol/scrollparent.js to be able to build with Rollup\n\nconst regex = /(auto|scroll)/\n\nfunction parents (node, ps) {\n  if (node.parentNode === null) { return ps }\n\n  return parents(node.parentNode, ps.concat([node]))\n}\n\nconst style = function (node, prop) {\n  return getComputedStyle(node, null).getPropertyValue(prop)\n}\n\nconst overflow = function (node) {\n  return style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x')\n}\n\nconst scroll = function (node) {\n  return regex.test(overflow(node))\n}\n\nexport function getScrollParent (node) {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return\n  }\n\n  const ps = parents(node.parentNode, [])\n\n  for (let i = 0; i < ps.length; i += 1) {\n    if (scroll(ps[i])) {\n      return ps[i]\n    }\n  }\n\n  return document.scrollingElement || document.documentElement\n}\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -999999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -999999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<script>\nimport { h } from 'vue'\n\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  emits: [\n    'resize',\n  ],\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField]\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)\n    },\n\n    size () {\n      return this.vscrollData.sizes[this.id] || 0\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id (value, oldValue) {\n      this.$el.$_vs_id = this.id\n      if (!this.size) {\n        this.onDataUpdate()\n      }\n\n      if (this.$_sizeObserved) {\n        // In case the old item had the same size, it won't trigger the ResizeObserver\n        // since we are reusing the same DOM node\n        const oldSize = this.vscrollData.sizes[oldValue]\n        const size = this.vscrollData.sizes[value]\n        if (oldSize != null && oldSize !== size) {\n          this.applySize(oldSize)\n        }\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++\n            this.vscrollParent.$_undefinedMap[this.id] = true\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--\n            this.vscrollParent.$_undefinedMap[this.id] = false\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize()\n        } else {\n          this.unobserveSize()\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize()\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return\n\n    this.$_forceNextVScrollUpdate = null\n    this.updateWatchData()\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\n      }\n\n      this.vscrollParent.$_events.on('vscroll:update', this.onVscrollUpdate)\n    }\n  },\n\n  mounted () {\n    if (this.finalActive) {\n      this.updateSize()\n      this.observeSize()\n    }\n  },\n\n  beforeUnmount () {\n    this.vscrollParent.$_events.off('vscroll:update', this.onVscrollUpdate)\n    this.unobserveSize()\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id\n          this.$_forceNextVScrollUpdate = null\n          this.$_pendingVScrollUpdate = null\n          this.computeSize(this.id)\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate()\n        }, {\n          deep: true,\n        })\n      } else if (this.$_watchData) {\n        this.$_watchData()\n        this.$_watchData = null\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize()\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize()\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth\n          const height = this.$el.offsetHeight\n          this.applyWidthHeight(width, height)\n        }\n        this.$_pendingSizeUpdate = null\n      })\n    },\n\n    applyWidthHeight (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width)\n      if (size && this.size !== size) {\n        this.applySize(size)\n      }\n    },\n\n    applySize (size) {\n      if (this.vscrollParent.$_undefinedMap[this.id]) {\n        this.vscrollParent.$_undefinedSizes--\n        this.vscrollParent.$_undefinedMap[this.id] = undefined\n      }\n      this.vscrollData.sizes[this.id] = size\n      if (this.emitResize) this.$emit('resize', this.id)\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return\n      if (this.$_sizeObserved) return\n      this.vscrollResizeObserver.observe(this.$el)\n      this.$el.$_vs_id = this.id\n      this.$el.$_vs_onResize = this.onResize\n      this.$_sizeObserved = true\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return\n      if (!this.$_sizeObserved) return\n      this.vscrollResizeObserver.unobserve(this.$el)\n      this.$el.$_vs_onResize = undefined\n      this.$_sizeObserved = false\n    },\n\n    onResize (id, width, height) {\n      if (this.id === id) {\n        this.applyWidthHeight(width, height)\n      }\n    },\n  },\n\n  render () {\n    return h(this.tag, this.$slots.default())\n  },\n}\n</script>\n","import { reactive } from 'vue'\n\nexport default function ({\n  idProp = vm => vm.item.id,\n} = {}) {\n  const store = reactive({})\n\n  // @vue/component\n  return {\n    data () {\n      return {\n        idState: null,\n      }\n    },\n\n    created () {\n      this.$_id = null\n      if (typeof idProp === 'function') {\n        this.$_getId = () => idProp.call(this, this)\n      } else {\n        this.$_getId = () => this[idProp]\n      }\n      this.$watch(this.$_getId, {\n        handler (value) {\n          this.$nextTick(() => {\n            this.$_id = value\n          })\n        },\n        immediate: true,\n      })\n      this.$_updateIdState()\n    },\n\n    beforeUpdate () {\n      this.$_updateIdState()\n    },\n\n    methods: {\n      /**\n       * Initialize an idState\n       * @param {number|string} id Unique id for the data\n       */\n      $_idStateInit (id) {\n        const factory = this.$options.idState\n        if (typeof factory === 'function') {\n          const data = factory.call(this, this)\n          store[id] = data\n          this.$_id = id\n          return data\n        } else {\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\n        }\n      },\n\n      /**\n       * Ensure idState is created and up-to-date\n       */\n      $_updateIdState () {\n        const id = this.$_getId()\n        if (id == null) {\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\n        }\n        if (id !== this.$_id) {\n          if (!store[id]) {\n            this.$_idStateInit(id)\n          }\n          this.idState = store[id]\n        }\n      },\n    },\n  }\n}\n","import config from './config'\n\nimport RecycleScroller from './components/RecycleScroller.vue'\nimport DynamicScroller from './components/DynamicScroller.vue'\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\n\nexport { default as IdState } from './mixins/IdState'\n\nexport {\n  RecycleScroller,\n  DynamicScroller,\n  DynamicScrollerItem,\n}\n\nfunction registerComponents (app, prefix) {\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\n}\n\nconst plugin = {\n  // eslint-disable-next-line no-undef\n  version: VERSION,\n  install (app, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: '',\n    }, options)\n\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key]\n      }\n    }\n\n    if (finalOptions.installComponents) {\n      registerComponents(app, finalOptions.componentsPrefix)\n    }\n  },\n}\n\nexport default plugin\n"],"names":["itemsLimit","regex","parents","node","ps","parentNode","concat","style","prop","getComputedStyle","getPropertyValue","overflow","scroll","test","getScrollParent","HTMLElement","SVGElement","i","length","document","scrollingElement","documentElement","props","items","type","Array","required","keyField","String","default","direction","validator","value","includes","listTag","itemTag","simpleArray","supportsPassive","window","opts","Object","defineProperty","get","addEventListener","e","ResizeObserver","_createElementBlock","_openBlock","_renderSlot","_createBlock","_resolveDynamicComponent","_normalizeStyle","_normalizeClass","_Fragment","_renderList","_mergeProps","_toHandlers","_createVNode","RecycleScroller","_normalizeProps","_guardReactiveProps","idProp","vm","item","id","store","reactive","data","idState","created","$_id","$_getId","call","$watch","handler","$nextTick","immediate","$_updateIdState","beforeUpdate","methods","$_idStateInit","factory","$options","Error","console","warn","registerComponents","app","prefix","component","DynamicScroller","DynamicScrollerItem","plugin","version","VERSION","install","options","finalOptions","assign","installComponents","componentsPrefix","key","config"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.min.js b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.min.js
index 88bc554..f8e8b13 100644
--- a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.min.js
+++ b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.min.js
@@ -1,2 +1,2 @@
-var VueVirtualScroller=function(e,t){"use strict";var i,s={itemsLimit:1e3};function r(){r.init||(r.init=!0,i=-1!==function(){var e=window.navigator.userAgent,t=e.indexOf("MSIE ");if(t>0)return parseInt(e.substring(t+5,e.indexOf(".",t)),10);if(e.indexOf("Trident/")>0){var i=e.indexOf("rv:");return parseInt(e.substring(i+3,e.indexOf(".",i)),10)}var s=e.indexOf("Edge/");return s>0?parseInt(e.substring(s+5,e.indexOf(".",s)),10):-1}())}var n={name:"ResizeObserver",props:{emitOnMount:{type:Boolean,default:!1},ignoreWidth:{type:Boolean,default:!1},ignoreHeight:{type:Boolean,default:!1}},emits:["notify"],mounted:function(){var e=this;r(),t.nextTick((function(){e._w=e.$el.offsetWidth,e._h=e.$el.offsetHeight,e.emitOnMount&&e.emitSize()}));var s=document.createElement("object");this._resizeObject=s,s.setAttribute("aria-hidden","true"),s.setAttribute("tabindex",-1),s.onload=this.addResizeHandlers,s.type="text/html",i&&this.$el.appendChild(s),s.data="about:blank",i||this.$el.appendChild(s)},beforeUnmount:function(){this.removeResizeHandlers()},methods:{compareAndNotify:function(){(!this.ignoreWidth&&this._w!==this.$el.offsetWidth||!this.ignoreHeight&&this._h!==this.$el.offsetHeight)&&(this._w=this.$el.offsetWidth,this._h=this.$el.offsetHeight,this.emitSize())},emitSize:function(){this.$emit("notify",{width:this._w,height:this._h})},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener("resize",this.compareAndNotify),this.compareAndNotify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!i&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener("resize",this.compareAndNotify),this.$el.removeChild(this._resizeObject),this._resizeObject.onload=null,this._resizeObject=null)}}},o=t.withScopeId("data-v-b329ee4c");t.pushScopeId("data-v-b329ee4c");var l={class:"resize-observer",tabindex:"-1"};t.popScopeId();var a=o((function(e,i,s,r,n,o){return t.openBlock(),t.createBlock("div",l)}));function c(e){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function d(e,t){for(var i=0;i<t.length;i++){var s=t[i];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}function h(e){return function(e){if(Array.isArray(e))return u(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return u(e,t);var i=Object.prototype.toString.call(e).slice(8,-1);"Object"===i&&e.constructor&&(i=e.constructor.name);if("Map"===i||"Set"===i)return Array.from(e);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return u(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function u(e,t){(null==t||t>e.length)&&(t=e.length);for(var i=0,s=new Array(t);i<t;i++)s[i]=e[i];return s}n.render=a,n.__scopeId="data-v-b329ee4c",n.__file="src/components/ResizeObserver.vue";var f=function(){function e(t,i,s){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.el=t,this.observer=null,this.frozen=!1,this.createObserver(i,s)}var i,s,r;return i=e,(s=[{key:"createObserver",value:function(e,i){var s=this;if(this.observer&&this.destroyObserver(),!this.frozen){var r;if(this.options="function"==typeof(r=e)?{callback:r}:r,this.callback=function(e,t){s.options.callback(e,t),e&&s.options.once&&(s.frozen=!0,s.destroyObserver())},this.callback&&this.options.throttle){var n=(this.options.throttleOptions||{}).leading;this.callback=function(e,t){var i,s,r,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=function(o){for(var l=arguments.length,a=new Array(l>1?l-1:0),c=1;c<l;c++)a[c-1]=arguments[c];if(r=a,!i||o!==s){var d=n.leading;"function"==typeof d&&(d=d(o,s)),i&&o===s||!d||e.apply(void 0,[o].concat(h(r))),s=o,clearTimeout(i),i=setTimeout((function(){e.apply(void 0,[o].concat(h(r))),i=0}),t)}};return o._clear=function(){clearTimeout(i),i=null},o}(this.callback,this.options.throttle,{leading:function(e){return"both"===n||"visible"===n&&e||"hidden"===n&&!e}})}this.oldResult=void 0,this.observer=new IntersectionObserver((function(e){var t=e[0];if(e.length>1){var i=e.find((function(e){return e.isIntersecting}));i&&(t=i)}if(s.callback){var r=t.isIntersecting&&t.intersectionRatio>=s.threshold;if(r===s.oldResult)return;s.oldResult=r,s.callback(r,t)}}),this.options.intersection),t.nextTick((function(){s.observer&&s.observer.observe(s.el)}))}}},{key:"destroyObserver",value:function(){this.observer&&(this.observer.disconnect(),this.observer=null),this.callback&&this.callback._clear&&(this.callback._clear(),this.callback=null)}},{key:"threshold",get:function(){return this.options.intersection&&"number"==typeof this.options.intersection.threshold?this.options.intersection.threshold:0}}])&&d(i.prototype,s),r&&d(i,r),e}();function m(e,t,i){var s=t.value;if(s)if("undefined"==typeof IntersectionObserver)console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");else{var r=new f(e,s,i);e._vue_visibilityState=r}}function p(e){var t=e._vue_visibilityState;t&&(t.destroyObserver(),delete e._vue_visibilityState)}var v={beforeMount:m,updated:function(e,t,i){var s=t.value;if(!function e(t,i){if(t===i)return!0;if("object"===c(t)){for(var s in t)if(!e(t[s],i[s]))return!1;return!0}return!1}(s,t.oldValue)){var r=e._vue_visibilityState;s?r?r.createObserver(s,i):m(e,{value:s},i):p(e)}},unmounted:p},y=/(auto|scroll)/;var b=function(e,t){return getComputedStyle(e,null).getPropertyValue(t)},g=function(e){return y.test(function(e){return b(e,"overflow")+b(e,"overflow-y")+b(e,"overflow-x")}(e))};function S(e){if(e instanceof HTMLElement||e instanceof SVGElement){for(var t=function e(t,i){return null===t.parentNode?i:e(t.parentNode,i.concat([t]))}(e.parentNode,[]),i=0;i<t.length;i+=1)if(g(t[i]))return t[i];return document.scrollingElement||document.documentElement}}function $(e){return($="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var z={items:{type:Array,required:!0},keyField:{type:String,default:"id"},direction:{type:String,default:"vertical",validator:function(e){return["vertical","horizontal"].includes(e)}},listTag:{type:String,default:"div"},itemTag:{type:String,default:"div"}};function _(){return this.items.length&&"object"!==$(this.items[0])}var w=!1;if("undefined"!=typeof window){w=!1;try{var I=Object.defineProperty({},"passive",{get:function(){w=!0}});window.addEventListener("test",null,I)}catch(e){}}let k=0;var x={name:"RecycleScroller",components:{ResizeObserver:n},directives:{ObserveVisibility:v},props:{...z,itemSize:{type:Number,default:null},gridItems:{type:Number,default:void 0},itemSecondarySize:{type:Number,default:void 0},minItemSize:{type:[Number,String],default:null},sizeField:{type:String,default:"size"},typeField:{type:String,default:"type"},buffer:{type:Number,default:200},pageMode:{type:Boolean,default:!1},prerender:{type:Number,default:0},emitUpdate:{type:Boolean,default:!1},updateInterval:{type:Number,default:0},skipHover:{type:Boolean,default:!1},listTag:{type:String,default:"div"},itemTag:{type:String,default:"div"},listClass:{type:[String,Object,Array],default:""},itemClass:{type:[String,Object,Array],default:""}},emits:["resize","visible","hidden","update","scroll-start","scroll-end"],data:()=>({pool:[],totalSize:0,ready:!1,hoverKey:null}),computed:{sizes(){if(null===this.itemSize){const e={"-1":{accumulator:0}},t=this.items,i=this.sizeField,s=this.minItemSize;let r,n=1e4,o=0;for(let l=0,a=t.length;l<a;l++)r=t[l][i]||s,r<n&&(n=r),o+=r,e[l]={accumulator:o,size:r};return this.$_computedMinItemSize=n,e}return[]},simpleArray:_,itemIndexByKey(){const{keyField:e,items:t}=this,i={};for(let s=0,r=t.length;s<r;s++)i[t[s][e]]=s;return i}},watch:{items(){this.updateVisibleItems(!0)},pageMode(){this.applyPageMode(),this.updateVisibleItems(!1)},sizes:{handler(){this.updateVisibleItems(!1)},deep:!0},gridItems(){this.updateVisibleItems(!0)},itemSecondarySize(){this.updateVisibleItems(!0)}},created(){this.$_startIndex=0,this.$_endIndex=0,this.$_views=new Map,this.$_unusedViews=new Map,this.$_scrollDirty=!1,this.$_lastUpdateScrollPosition=0,this.prerender&&(this.$_prerender=!0,this.updateVisibleItems(!1)),this.gridItems&&!this.itemSize&&console.error("[vue-recycle-scroller] You must provide an itemSize when using gridItems")},mounted(){this.applyPageMode(),this.$nextTick(()=>{this.$_prerender=!1,this.updateVisibleItems(!0),this.ready=!0})},activated(){const e=this.$_lastUpdateScrollPosition;"number"==typeof e&&this.$nextTick(()=>{this.scrollToPosition(e)})},beforeUnmount(){this.removeListeners()},methods:{addView(e,i,s,r,n){const o=t.markRaw({id:k++,index:i,used:!0,key:r,type:n}),l=t.shallowReactive({item:s,position:0,nr:o});return e.push(l),l},unuseView(e,t=!1){const i=this.$_unusedViews,s=e.nr.type;let r=i.get(s);r||(r=[],i.set(s,r)),r.push(e),t||(e.nr.used=!1,e.position=-9999)},handleResize(){this.$emit("resize"),this.ready&&this.updateVisibleItems(!1)},handleScroll(e){if(!this.$_scrollDirty){if(this.$_scrollDirty=!0,this.$_updateTimeout)return;const e=()=>requestAnimationFrame(()=>{this.$_scrollDirty=!1;const{continuous:e}=this.updateVisibleItems(!1,!0);e||(clearTimeout(this.$_refreshTimout),this.$_refreshTimout=setTimeout(this.handleScroll,this.updateInterval+100))});e(),this.updateInterval&&(this.$_updateTimeout=setTimeout(()=>{this.$_updateTimeout=0,this.$_scrollDirty&&e()},this.updateInterval))}},handleVisibilityChange(e,t){this.ready&&(e||0!==t.boundingClientRect.width||0!==t.boundingClientRect.height?(this.$emit("visible"),requestAnimationFrame(()=>{this.updateVisibleItems(!1)})):this.$emit("hidden"))},updateVisibleItems(e,t=!1){const i=this.itemSize,r=this.gridItems||1,n=this.itemSecondarySize||i,o=this.$_computedMinItemSize,l=this.typeField,a=this.simpleArray?null:this.keyField,c=this.items,d=c.length,h=this.sizes,u=this.$_views,f=this.$_unusedViews,m=this.pool,p=this.itemIndexByKey;let v,y,b,g,S,$;if(d)if(this.$_prerender)v=g=0,y=S=Math.min(this.prerender,c.length),b=null;else{const e=this.getScroll();if(t){let t=e.start-this.$_lastUpdateScrollPosition;if(t<0&&(t=-t),null===i&&t<o||t<i)return{continuous:!0}}this.$_lastUpdateScrollPosition=e.start;const s=this.buffer;e.start-=s,e.end+=s;let n=0;if(this.$refs.before&&(n=this.$refs.before.scrollHeight,e.start-=n),this.$refs.after){const t=this.$refs.after.scrollHeight;e.end+=t}if(null===i){let t,i,s=0,r=d-1,o=~~(d/2);do{i=o,t=h[o].accumulator,t<e.start?s=o:o<d-1&&h[o+1].accumulator>e.start&&(r=o),o=~~((s+r)/2)}while(o!==i);for(o<0&&(o=0),v=o,b=h[d-1].accumulator,y=o;y<d&&h[y].accumulator<e.end;y++);for(-1===y?y=c.length-1:(y++,y>d&&(y=d)),g=v;g<d&&n+h[g].accumulator<e.start;g++);for(S=g;S<d&&n+h[S].accumulator<e.end;S++);}else{v=~~(e.start/i*r);v-=v%r,y=Math.ceil(e.end/i*r),g=Math.max(0,Math.floor((e.start-n)/i*r)),S=Math.floor((e.end-n)/i*r),v<0&&(v=0),y>d&&(y=d),g<0&&(g=0),S>d&&(S=d),b=Math.ceil(d/r)*i}}else v=y=g=S=b=0;y-v>s.itemsLimit&&this.itemsLimitError(),this.totalSize=b;const z=v<=this.$_endIndex&&y>=this.$_startIndex;if(z)for(let t=0,i=m.length;t<i;t++)$=m[t],$.nr.used&&(e&&($.nr.index=p[$.item[a]]),(null==$.nr.index||$.nr.index<v||$.nr.index>=y)&&this.unuseView($));const _=z?null:new Map;let w,I,k;for(let e=v;e<y;e++){w=c[e];const t=a?w[a]:w;if(null==t)throw new Error(`Key is ${t} on item (keyField is '${a}')`);if($=u.get(t),!i&&!h[e].size){$&&this.unuseView($);continue}I=w[l];let s=f.get(I),o=!1;if($){if(!$.nr.used&&($.nr.used=!0,o=!0,s)){const e=s.indexOf($);-1!==e&&s.splice(e,1)}}else z?$=s&&s.length?s.pop():this.addView(m,e,w,t,I):(k=_.get(I)||0,(!s||k>=s.length)&&($=this.addView(m,e,w,t,I),this.unuseView($,!0),s=f.get(I)),$=s[k],_.set(I,k+1)),u.delete($.nr.key),$.nr.used=!0,$.nr.index=e,$.nr.key=t,$.nr.type=I,u.set(t,$),o=!0;$.item=w,o&&(e===c.length-1&&this.$emit("scroll-end"),0===e&&this.$emit("scroll-start")),null===i?($.position=h[e-1].accumulator,$.offset=0):($.position=Math.floor(e/r)*i,$.offset=e%r*n)}return this.$_startIndex=v,this.$_endIndex=y,this.emitUpdate&&this.$emit("update",v,y,g,S),clearTimeout(this.$_sortTimer),this.$_sortTimer=setTimeout(this.sortViews,this.updateInterval+300),{continuous:z}},getListenerTarget(){let e=S(this.$el);return!window.document||e!==window.document.documentElement&&e!==window.document.body||(e=window),e},getScroll(){const{$el:e,direction:t}=this,i="vertical"===t;let s;if(this.pageMode){const t=e.getBoundingClientRect(),r=i?t.height:t.width;let n=-(i?t.top:t.left),o=i?window.innerHeight:window.innerWidth;n<0&&(o+=n,n=0),n+o>r&&(o=r-n),s={start:n,end:n+o}}else s=i?{start:e.scrollTop,end:e.scrollTop+e.clientHeight}:{start:e.scrollLeft,end:e.scrollLeft+e.clientWidth};return s},applyPageMode(){this.pageMode?this.addListeners():this.removeListeners()},addListeners(){this.listenerTarget=this.getListenerTarget(),this.listenerTarget.addEventListener("scroll",this.handleScroll,!!w&&{passive:!0}),this.listenerTarget.addEventListener("resize",this.handleResize)},removeListeners(){this.listenerTarget&&(this.listenerTarget.removeEventListener("scroll",this.handleScroll),this.listenerTarget.removeEventListener("resize",this.handleResize),this.listenerTarget=null)},scrollToItem(e){let t;const i=this.gridItems||1;t=null===this.itemSize?e>0?this.sizes[e-1].accumulator:0:Math.floor(e/i)*this.itemSize,this.scrollToPosition(t)},scrollToPosition(e){const t="vertical"===this.direction?{scroll:"scrollTop",start:"top"}:{scroll:"scrollLeft",start:"left"};let i,s,r;if(this.pageMode){const n=S(this.$el),o="HTML"===n.tagName?0:n[t.scroll],l=n.getBoundingClientRect(),a=this.$el.getBoundingClientRect()[t.start]-l[t.start];i=n,s=t.scroll,r=e+o+a}else i=this.$el,s=t.scroll,r=e;i[s]=r},itemsLimitError(){throw setTimeout(()=>{console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.","Scroller:",this.$el),console.log("Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.")}),new Error("Rendered items limit reached")},sortViews(){this.pool.sort((e,t)=>e.nr.index-t.nr.index)}}};const O={key:0,ref:"before",class:"vue-recycle-scroller__slot"},T={key:1,ref:"after",class:"vue-recycle-scroller__slot"};x.render=function(e,i,s,r,n,o){const l=t.resolveComponent("ResizeObserver"),a=t.resolveDirective("observe-visibility");return t.withDirectives((t.openBlock(),t.createElementBlock("div",{class:t.normalizeClass(["vue-recycle-scroller",{ready:n.ready,"page-mode":s.pageMode,["direction-"+e.direction]:!0}]),onScrollPassive:i[0]||(i[0]=(...e)=>o.handleScroll&&o.handleScroll(...e))},[e.$slots.before?(t.openBlock(),t.createElementBlock("div",O,[t.renderSlot(e.$slots,"before")],512)):t.createCommentVNode("v-if",!0),(t.openBlock(),t.createBlock(t.resolveDynamicComponent(s.listTag),{ref:"wrapper",style:t.normalizeStyle({["vertical"===e.direction?"minHeight":"minWidth"]:n.totalSize+"px"}),class:t.normalizeClass(["vue-recycle-scroller__item-wrapper",s.listClass])},{default:t.withCtx(()=>[(t.openBlock(!0),t.createElementBlock(t.Fragment,null,t.renderList(n.pool,i=>(t.openBlock(),t.createBlock(t.resolveDynamicComponent(s.itemTag),t.mergeProps({key:i.nr.id,style:n.ready?{transform:`translate${"vertical"===e.direction?"Y":"X"}(${i.position}px) translate${"vertical"===e.direction?"X":"Y"}(${i.offset}px)`,width:s.gridItems?("vertical"===e.direction&&s.itemSecondarySize||s.itemSize)+"px":void 0,height:s.gridItems?("horizontal"===e.direction&&s.itemSecondarySize||s.itemSize)+"px":void 0}:null,class:["vue-recycle-scroller__item-view",[s.itemClass,{hover:!s.skipHover&&n.hoverKey===i.nr.key}]]},t.toHandlers(s.skipHover?{}:{mouseenter:()=>{n.hoverKey=i.nr.key},mouseleave:()=>{n.hoverKey=null}})),{default:t.withCtx(()=>[t.renderSlot(e.$slots,"default",{item:i.item,index:i.nr.index,active:i.nr.used})]),_:2},1040,["style","class"]))),128)),t.renderSlot(e.$slots,"empty")]),_:3},8,["style","class"])),e.$slots.after?(t.openBlock(),t.createElementBlock("div",T,[t.renderSlot(e.$slots,"after")],512)):t.createCommentVNode("v-if",!0),t.createVNode(l,{onNotify:o.handleResize},null,8,["onNotify"])],34)),[[a,o.handleVisibilityChange]])},x.__file="src/components/RecycleScroller.vue";var D={name:"DynamicScroller",components:{RecycleScroller:x},provide(){return"undefined"!=typeof ResizeObserver&&(this.$_resizeObserver=new ResizeObserver(e=>{requestAnimationFrame(()=>{if(Array.isArray(e))for(const t of e)if(t.target&&t.target.$_vs_onResize){let e,i;if(t.borderBoxSize){const s=t.borderBoxSize[0];e=s.inlineSize,i=s.blockSize}else e=t.contentRect.width,i=t.contentRect.height;t.target.$_vs_onResize(t.target.$_vs_id,e,i)}})})),{vscrollData:this.vscrollData,vscrollParent:this,vscrollResizeObserver:this.$_resizeObserver}},inheritAttrs:!1,props:{...z,minItemSize:{type:[Number,String],required:!0}},emits:["resize","visible"],data(){return{vscrollData:{active:!0,sizes:{},keyField:this.keyField,simpleArray:!1}}},computed:{simpleArray:_,itemsWithSize(){const e=[],{items:t,keyField:i,simpleArray:s}=this,r=this.vscrollData.sizes,n=t.length;for(let o=0;o<n;o++){const n=t[o],l=s?o:n[i];let a=r[l];void 0!==a||this.$_undefinedMap[l]||(a=0),e.push({item:n,id:l,size:a})}return e}},watch:{items(){this.forceUpdate()},simpleArray:{handler(e){this.vscrollData.simpleArray=e},immediate:!0},direction(e){this.forceUpdate(!0)},itemsWithSize(e,t){const i=this.$el.scrollTop;let s=0,r=0;const n=Math.min(e.length,t.length);for(let o=0;o<n&&!(s>=i);o++)s+=t[o].size||this.minItemSize,r+=e[o].size||this.minItemSize;const o=r-s;0!==o&&(this.$el.scrollTop+=o)}},beforeCreate(){var e;this.$_updates=[],this.$_undefinedSizes=0,this.$_undefinedMap={},this.$_events={all:e=e||new Map,on:function(t,i){var s=e.get(t);s&&s.push(i)||e.set(t,[i])},off:function(t,i){var s=e.get(t);s&&s.splice(s.indexOf(i)>>>0,1)},emit:function(t,i){(e.get(t)||[]).slice().map((function(e){e(i)})),(e.get("*")||[]).slice().map((function(e){e(t,i)}))}}},activated(){this.vscrollData.active=!0},deactivated(){this.vscrollData.active=!1},unmounted(){this.$_events.all.clear()},methods:{onScrollerResize(){this.$refs.scroller&&this.forceUpdate(),this.$emit("resize")},onScrollerVisible(){this.$_events.emit("vscroll:update",{force:!1}),this.$emit("visible")},forceUpdate(e=!1){(e||this.simpleArray)&&(this.vscrollData.sizes={}),this.$_events.emit("vscroll:update",{force:!0})},scrollToItem(e){const t=this.$refs.scroller;t&&t.scrollToItem(e)},getItemSize(e,t){const i=this.simpleArray?null!=t?t:this.items.indexOf(e):e[this.keyField];return this.vscrollData.sizes[i]||0},scrollToBottom(){if(this.$_scrollingToBottom)return;this.$_scrollingToBottom=!0;const e=this.$el;this.$nextTick(()=>{e.scrollTop=e.scrollHeight+5e3;const t=()=>{e.scrollTop=e.scrollHeight+5e3,requestAnimationFrame(()=>{e.scrollTop=e.scrollHeight+5e3,0===this.$_undefinedSizes?this.$_scrollingToBottom=!1:requestAnimationFrame(t)})};requestAnimationFrame(t)})}}};D.render=function(e,i,s,r,n,o){const l=t.resolveComponent("RecycleScroller");return t.openBlock(),t.createBlock(l,t.mergeProps({ref:"scroller",items:o.itemsWithSize,"min-item-size":s.minItemSize,direction:e.direction,"key-field":"id","list-tag":e.listTag,"item-tag":e.itemTag},e.$attrs,{onResize:o.onScrollerResize,onVisible:o.onScrollerVisible}),{default:t.withCtx(({item:i,index:s,active:r})=>[t.renderSlot(e.$slots,"default",t.normalizeProps(t.guardReactiveProps({item:i.item,index:s,active:r,itemWithSize:i})))]),before:t.withCtx(()=>[t.renderSlot(e.$slots,"before")]),after:t.withCtx(()=>[t.renderSlot(e.$slots,"after")]),empty:t.withCtx(()=>[t.renderSlot(e.$slots,"empty")]),_:3},16,["items","min-item-size","direction","list-tag","item-tag","onResize","onVisible"])},D.__file="src/components/DynamicScroller.vue";var R={name:"DynamicScrollerItem",inject:["vscrollData","vscrollParent","vscrollResizeObserver"],props:{item:{required:!0},watchData:{type:Boolean,default:!1},active:{type:Boolean,required:!0},index:{type:Number,default:void 0},sizeDependencies:{type:[Array,Object],default:null},emitResize:{type:Boolean,default:!1},tag:{type:String,default:"div"}},emits:["resize"],computed:{id(){if(this.vscrollData.simpleArray)return this.index;if(this.vscrollData.keyField in this.item)return this.item[this.vscrollData.keyField];throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)},size(){return this.vscrollData.sizes[this.id]||0},finalActive(){return this.active&&this.vscrollData.active}},watch:{watchData:"updateWatchData",id(e,t){if(this.$el.$_vs_id=this.id,this.size||this.onDataUpdate(),this.$_sizeObserved){const i=this.vscrollData.sizes[t],s=this.vscrollData.sizes[e];null!=i&&i!==s&&this.applySize(i)}},finalActive(e){this.size||(e?this.vscrollParent.$_undefinedMap[this.id]||(this.vscrollParent.$_undefinedSizes++,this.vscrollParent.$_undefinedMap[this.id]=!0):this.vscrollParent.$_undefinedMap[this.id]&&(this.vscrollParent.$_undefinedSizes--,this.vscrollParent.$_undefinedMap[this.id]=!1)),this.vscrollResizeObserver?e?this.observeSize():this.unobserveSize():e&&this.$_pendingVScrollUpdate===this.id&&this.updateSize()}},created(){if(!this.$isServer&&(this.$_forceNextVScrollUpdate=null,this.updateWatchData(),!this.vscrollResizeObserver)){for(const e in this.sizeDependencies)this.$watch(()=>this.sizeDependencies[e],this.onDataUpdate);this.vscrollParent.$_events.on("vscroll:update",this.onVscrollUpdate)}},mounted(){this.finalActive&&(this.updateSize(),this.observeSize())},beforeUnmount(){this.vscrollParent.$_events.off("vscroll:update",this.onVscrollUpdate),this.unobserveSize()},methods:{updateSize(){this.finalActive?this.$_pendingSizeUpdate!==this.id&&(this.$_pendingSizeUpdate=this.id,this.$_forceNextVScrollUpdate=null,this.$_pendingVScrollUpdate=null,this.computeSize(this.id)):this.$_forceNextVScrollUpdate=this.id},updateWatchData(){this.watchData&&!this.vscrollResizeObserver?this.$_watchData=this.$watch("item",()=>{this.onDataUpdate()},{deep:!0}):this.$_watchData&&(this.$_watchData(),this.$_watchData=null)},onVscrollUpdate({force:e}){!this.finalActive&&e&&(this.$_pendingVScrollUpdate=this.id),this.$_forceNextVScrollUpdate!==this.id&&!e&&this.size||this.updateSize()},onDataUpdate(){this.updateSize()},computeSize(e){this.$nextTick(()=>{if(this.id===e){const e=this.$el.offsetWidth,t=this.$el.offsetHeight;this.applyWidthHeight(e,t)}this.$_pendingSizeUpdate=null})},applyWidthHeight(e,t){const i=~~("vertical"===this.vscrollParent.direction?t:e);i&&this.size!==i&&this.applySize(i)},applySize(e){this.vscrollParent.$_undefinedMap[this.id]&&(this.vscrollParent.$_undefinedSizes--,this.vscrollParent.$_undefinedMap[this.id]=void 0),this.vscrollData.sizes[this.id]=e,this.emitResize&&this.$emit("resize",this.id)},observeSize(){this.vscrollResizeObserver&&(this.$_sizeObserved||(this.vscrollResizeObserver.observe(this.$el),this.$el.$_vs_id=this.id,this.$el.$_vs_onResize=this.onResize,this.$_sizeObserved=!0))},unobserveSize(){this.vscrollResizeObserver&&this.$_sizeObserved&&(this.vscrollResizeObserver.unobserve(this.$el),this.$el.$_vs_onResize=void 0,this.$_sizeObserved=!1)},onResize(e,t,i){this.id===e&&this.applyWidthHeight(t,i)}},render(){return t.h(this.tag,this.$slots.default())}};R.__file="src/components/DynamicScrollerItem.vue";var V={version:"2.0.0-beta.8",install:function(e,t){var i=Object.assign({},{installComponents:!0,componentsPrefix:""},t);for(var r in i)void 0!==i[r]&&(s[r]=i[r]);i.installComponents&&function(e,t){e.component("".concat(t,"recycle-scroller"),x),e.component("".concat(t,"RecycleScroller"),x),e.component("".concat(t,"dynamic-scroller"),D),e.component("".concat(t,"DynamicScroller"),D),e.component("".concat(t,"dynamic-scroller-item"),R),e.component("".concat(t,"DynamicScrollerItem"),R)}(e,i.componentsPrefix)}};return e.DynamicScroller=D,e.DynamicScrollerItem=R,e.IdState=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=e.idProp,s=void 0===i?function(e){return e.item.id}:i,r=t.reactive({});return{data:function(){return{idState:null}},created:function(){var e=this;this.$_id=null,this.$_getId="function"==typeof s?function(){return s.call(e,e)}:function(){return e[s]},this.$watch(this.$_getId,{handler:function(e){var t=this;this.$nextTick((function(){t.$_id=e}))},immediate:!0}),this.$_updateIdState()},beforeUpdate:function(){this.$_updateIdState()},methods:{$_idStateInit:function(e){var t=this.$options.idState;if("function"==typeof t){var i=t.call(this,this);return r[e]=i,this.$_id=e,i}throw new Error("[mixin IdState] Missing `idState` function on component definition.")},$_updateIdState:function(){var e=this.$_getId();null==e&&console.warn("No id found for IdState with idProp: '".concat(s,"'.")),e!==this.$_id&&(r[e]||this.$_idStateInit(e),this.idState=r[e])}}}},e.RecycleScroller=x,e.default=V,Object.defineProperty(e,"__esModule",{value:!0}),e}({},Vue);
+var VueVirtualScroller=function(e,t){"use strict";var i,s={itemsLimit:1e3};function r(){r.init||(r.init=!0,i=-1!==function(){var e=window.navigator.userAgent,t=e.indexOf("MSIE ");if(t>0)return parseInt(e.substring(t+5,e.indexOf(".",t)),10);if(e.indexOf("Trident/")>0){var i=e.indexOf("rv:");return parseInt(e.substring(i+3,e.indexOf(".",i)),10)}var s=e.indexOf("Edge/");return s>0?parseInt(e.substring(s+5,e.indexOf(".",s)),10):-1}())}var n={name:"ResizeObserver",props:{emitOnMount:{type:Boolean,default:!1},ignoreWidth:{type:Boolean,default:!1},ignoreHeight:{type:Boolean,default:!1}},emits:["notify"],mounted:function(){var e=this;r(),t.nextTick((function(){e._w=e.$el.offsetWidth,e._h=e.$el.offsetHeight,e.emitOnMount&&e.emitSize()}));var s=document.createElement("object");this._resizeObject=s,s.setAttribute("aria-hidden","true"),s.setAttribute("tabindex",-1),s.onload=this.addResizeHandlers,s.type="text/html",i&&this.$el.appendChild(s),s.data="about:blank",i||this.$el.appendChild(s)},beforeUnmount:function(){this.removeResizeHandlers()},methods:{compareAndNotify:function(){(!this.ignoreWidth&&this._w!==this.$el.offsetWidth||!this.ignoreHeight&&this._h!==this.$el.offsetHeight)&&(this._w=this.$el.offsetWidth,this._h=this.$el.offsetHeight,this.emitSize())},emitSize:function(){this.$emit("notify",{width:this._w,height:this._h})},addResizeHandlers:function(){this._resizeObject.contentDocument.defaultView.addEventListener("resize",this.compareAndNotify),this.compareAndNotify()},removeResizeHandlers:function(){this._resizeObject&&this._resizeObject.onload&&(!i&&this._resizeObject.contentDocument&&this._resizeObject.contentDocument.defaultView.removeEventListener("resize",this.compareAndNotify),this.$el.removeChild(this._resizeObject),this._resizeObject.onload=null,this._resizeObject=null)}}},o=t.withScopeId("data-v-b329ee4c");t.pushScopeId("data-v-b329ee4c");var l={class:"resize-observer",tabindex:"-1"};t.popScopeId();var a=o((function(e,i,s,r,n,o){return t.openBlock(),t.createBlock("div",l)}));function c(e){return(c="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function d(e,t){for(var i=0;i<t.length;i++){var s=t[i];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(e,s.key,s)}}function h(e){return function(e){if(Array.isArray(e))return u(e)}(e)||function(e){if("undefined"!=typeof Symbol&&Symbol.iterator in Object(e))return Array.from(e)}(e)||function(e,t){if(!e)return;if("string"==typeof e)return u(e,t);var i=Object.prototype.toString.call(e).slice(8,-1);"Object"===i&&e.constructor&&(i=e.constructor.name);if("Map"===i||"Set"===i)return Array.from(e);if("Arguments"===i||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i))return u(e,t)}(e)||function(){throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}()}function u(e,t){(null==t||t>e.length)&&(t=e.length);for(var i=0,s=new Array(t);i<t;i++)s[i]=e[i];return s}n.render=a,n.__scopeId="data-v-b329ee4c",n.__file="src/components/ResizeObserver.vue";var f=function(){function e(t,i,s){!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.el=t,this.observer=null,this.frozen=!1,this.createObserver(i,s)}var i,s,r;return i=e,(s=[{key:"createObserver",value:function(e,i){var s=this;if(this.observer&&this.destroyObserver(),!this.frozen){var r;if(this.options="function"==typeof(r=e)?{callback:r}:r,this.callback=function(e,t){s.options.callback(e,t),e&&s.options.once&&(s.frozen=!0,s.destroyObserver())},this.callback&&this.options.throttle){var n=(this.options.throttleOptions||{}).leading;this.callback=function(e,t){var i,s,r,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},o=function(o){for(var l=arguments.length,a=new Array(l>1?l-1:0),c=1;c<l;c++)a[c-1]=arguments[c];if(r=a,!i||o!==s){var d=n.leading;"function"==typeof d&&(d=d(o,s)),i&&o===s||!d||e.apply(void 0,[o].concat(h(r))),s=o,clearTimeout(i),i=setTimeout((function(){e.apply(void 0,[o].concat(h(r))),i=0}),t)}};return o._clear=function(){clearTimeout(i),i=null},o}(this.callback,this.options.throttle,{leading:function(e){return"both"===n||"visible"===n&&e||"hidden"===n&&!e}})}this.oldResult=void 0,this.observer=new IntersectionObserver((function(e){var t=e[0];if(e.length>1){var i=e.find((function(e){return e.isIntersecting}));i&&(t=i)}if(s.callback){var r=t.isIntersecting&&t.intersectionRatio>=s.threshold;if(r===s.oldResult)return;s.oldResult=r,s.callback(r,t)}}),this.options.intersection),t.nextTick((function(){s.observer&&s.observer.observe(s.el)}))}}},{key:"destroyObserver",value:function(){this.observer&&(this.observer.disconnect(),this.observer=null),this.callback&&this.callback._clear&&(this.callback._clear(),this.callback=null)}},{key:"threshold",get:function(){return this.options.intersection&&"number"==typeof this.options.intersection.threshold?this.options.intersection.threshold:0}}])&&d(i.prototype,s),r&&d(i,r),e}();function m(e,t,i){var s=t.value;if(s)if("undefined"==typeof IntersectionObserver)console.warn("[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill");else{var r=new f(e,s,i);e._vue_visibilityState=r}}function p(e){var t=e._vue_visibilityState;t&&(t.destroyObserver(),delete e._vue_visibilityState)}var v={beforeMount:m,updated:function(e,t,i){var s=t.value;if(!function e(t,i){if(t===i)return!0;if("object"===c(t)){for(var s in t)if(!e(t[s],i[s]))return!1;return!0}return!1}(s,t.oldValue)){var r=e._vue_visibilityState;s?r?r.createObserver(s,i):m(e,{value:s},i):p(e)}},unmounted:p},y=/(auto|scroll)/;var b=function(e,t){return getComputedStyle(e,null).getPropertyValue(t)},g=function(e){return y.test(function(e){return b(e,"overflow")+b(e,"overflow-y")+b(e,"overflow-x")}(e))};function S(e){if(e instanceof HTMLElement||e instanceof SVGElement){for(var t=function e(t,i){return null===t.parentNode?i:e(t.parentNode,i.concat([t]))}(e.parentNode,[]),i=0;i<t.length;i+=1)if(g(t[i]))return t[i];return document.scrollingElement||document.documentElement}}function $(e){return($="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}var z={items:{type:Array,required:!0},keyField:{type:String,default:"id"},direction:{type:String,default:"vertical",validator:function(e){return["vertical","horizontal"].includes(e)}},listTag:{type:String,default:"div"},itemTag:{type:String,default:"div"}};function _(){return this.items.length&&"object"!==$(this.items[0])}var w=!1;if("undefined"!=typeof window){w=!1;try{var I=Object.defineProperty({},"passive",{get:function(){w=!0}});window.addEventListener("test",null,I)}catch(e){}}let k=0;var x={name:"RecycleScroller",components:{ResizeObserver:n},directives:{ObserveVisibility:v},props:{...z,itemSize:{type:Number,default:null},gridItems:{type:Number,default:void 0},itemSecondarySize:{type:Number,default:void 0},minItemSize:{type:[Number,String],default:null},sizeField:{type:String,default:"size"},typeField:{type:String,default:"type"},buffer:{type:Number,default:200},pageMode:{type:Boolean,default:!1},prerender:{type:Number,default:0},emitUpdate:{type:Boolean,default:!1},updateInterval:{type:Number,default:0},skipHover:{type:Boolean,default:!1},listTag:{type:String,default:"div"},itemTag:{type:String,default:"div"},listClass:{type:[String,Object,Array],default:""},itemClass:{type:[String,Object,Array],default:""}},emits:["resize","visible","hidden","update","scroll-start","scroll-end"],data:()=>({pool:[],totalSize:0,ready:!1,hoverKey:null}),computed:{sizes(){if(null===this.itemSize){const e={"-1":{accumulator:0}},t=this.items,i=this.sizeField,s=this.minItemSize;let r,n=1e4,o=0;for(let l=0,a=t.length;l<a;l++)r=t[l][i]||s,r<n&&(n=r),o+=r,e[l]={accumulator:o,size:r};return this.$_computedMinItemSize=n,e}return[]},simpleArray:_,itemIndexByKey(){const{keyField:e,items:t}=this,i={};for(let s=0,r=t.length;s<r;s++)i[t[s][e]]=s;return i}},watch:{items(){this.updateVisibleItems(!0)},pageMode(){this.applyPageMode(),this.updateVisibleItems(!1)},sizes:{handler(){this.updateVisibleItems(!1)},deep:!0},gridItems(){this.updateVisibleItems(!0)},itemSecondarySize(){this.updateVisibleItems(!0)}},created(){this.$_startIndex=0,this.$_endIndex=0,this.$_views=new Map,this.$_unusedViews=new Map,this.$_scrollDirty=!1,this.$_lastUpdateScrollPosition=0,this.prerender&&(this.$_prerender=!0,this.updateVisibleItems(!1)),this.gridItems&&!this.itemSize&&console.error("[vue-recycle-scroller] You must provide an itemSize when using gridItems")},mounted(){this.applyPageMode(),this.$nextTick(()=>{this.$_prerender=!1,this.updateVisibleItems(!0),this.ready=!0})},activated(){const e=this.$_lastUpdateScrollPosition;"number"==typeof e&&this.$nextTick(()=>{this.scrollToPosition(e)})},beforeUnmount(){this.removeListeners()},methods:{addView(e,i,s,r,n){const o=t.markRaw({id:k++,index:i,used:!0,key:r,type:n}),l=t.shallowReactive({item:s,position:0,nr:o});return e.push(l),l},unuseView(e,t=!1){const i=this.$_unusedViews,s=e.nr.type;let r=i.get(s);r||(r=[],i.set(s,r)),r.push(e),t||(e.nr.used=!1,e.position=-999999)},handleResize(){this.$emit("resize"),this.ready&&this.updateVisibleItems(!1)},handleScroll(e){if(!this.$_scrollDirty){if(this.$_scrollDirty=!0,this.$_updateTimeout)return;const e=()=>requestAnimationFrame(()=>{this.$_scrollDirty=!1;const{continuous:e}=this.updateVisibleItems(!1,!0);e||(clearTimeout(this.$_refreshTimout),this.$_refreshTimout=setTimeout(this.handleScroll,this.updateInterval+100))});e(),this.updateInterval&&(this.$_updateTimeout=setTimeout(()=>{this.$_updateTimeout=0,this.$_scrollDirty&&e()},this.updateInterval))}},handleVisibilityChange(e,t){this.ready&&(e||0!==t.boundingClientRect.width||0!==t.boundingClientRect.height?(this.$emit("visible"),requestAnimationFrame(()=>{this.updateVisibleItems(!1)})):this.$emit("hidden"))},updateVisibleItems(e,t=!1){const i=this.itemSize,r=this.gridItems||1,n=this.itemSecondarySize||i,o=this.$_computedMinItemSize,l=this.typeField,a=this.simpleArray?null:this.keyField,c=this.items,d=c.length,h=this.sizes,u=this.$_views,f=this.$_unusedViews,m=this.pool,p=this.itemIndexByKey;let v,y,b,g,S,$;if(d)if(this.$_prerender)v=g=0,y=S=Math.min(this.prerender,c.length),b=null;else{const e=this.getScroll();if(t){let t=e.start-this.$_lastUpdateScrollPosition;if(t<0&&(t=-t),null===i&&t<o||t<i)return{continuous:!0}}this.$_lastUpdateScrollPosition=e.start;const s=this.buffer;e.start-=s,e.end+=s;let n=0;if(this.$refs.before&&(n=this.$refs.before.scrollHeight,e.start-=n),this.$refs.after){const t=this.$refs.after.scrollHeight;e.end+=t}if(null===i){let t,i,s=0,r=d-1,o=~~(d/2);do{i=o,t=h[o].accumulator,t<e.start?s=o:o<d-1&&h[o+1].accumulator>e.start&&(r=o),o=~~((s+r)/2)}while(o!==i);for(o<0&&(o=0),v=o,b=h[d-1].accumulator,y=o;y<d&&h[y].accumulator<e.end;y++);for(-1===y?y=c.length-1:(y++,y>d&&(y=d)),g=v;g<d&&n+h[g].accumulator<e.start;g++);for(S=g;S<d&&n+h[S].accumulator<e.end;S++);}else{v=~~(e.start/i*r);v-=v%r,y=Math.ceil(e.end/i*r),g=Math.max(0,Math.floor((e.start-n)/i*r)),S=Math.floor((e.end-n)/i*r),v<0&&(v=0),y>d&&(y=d),g<0&&(g=0),S>d&&(S=d),b=Math.ceil(d/r)*i}}else v=y=g=S=b=0;y-v>s.itemsLimit&&this.itemsLimitError(),this.totalSize=b;const z=v<=this.$_endIndex&&y>=this.$_startIndex;if(z)for(let t=0,i=m.length;t<i;t++)$=m[t],$.nr.used&&(e&&($.nr.index=p[$.item[a]]),(null==$.nr.index||$.nr.index<v||$.nr.index>=y)&&this.unuseView($));const _=z?null:new Map;let w,I,k;for(let e=v;e<y;e++){w=c[e];const t=a?w[a]:w;if(null==t)throw new Error(`Key is ${t} on item (keyField is '${a}')`);if($=u.get(t),!i&&!h[e].size){$&&this.unuseView($);continue}I=w[l];let s=f.get(I),o=!1;if($){if(!$.nr.used&&($.nr.used=!0,o=!0,s)){const e=s.indexOf($);-1!==e&&s.splice(e,1)}}else z?$=s&&s.length?s.pop():this.addView(m,e,w,t,I):(k=_.get(I)||0,(!s||k>=s.length)&&($=this.addView(m,e,w,t,I),this.unuseView($,!0),s=f.get(I)),$=s[k],_.set(I,k+1)),u.delete($.nr.key),$.nr.used=!0,$.nr.index=e,$.nr.key=t,$.nr.type=I,u.set(t,$),o=!0;$.item=w,o&&(e===c.length-1&&this.$emit("scroll-end"),0===e&&this.$emit("scroll-start")),null===i?($.position=h[e-1].accumulator,$.offset=0):($.position=Math.floor(e/r)*i,$.offset=e%r*n)}return this.$_startIndex=v,this.$_endIndex=y,this.emitUpdate&&this.$emit("update",v,y,g,S),clearTimeout(this.$_sortTimer),this.$_sortTimer=setTimeout(this.sortViews,this.updateInterval+300),{continuous:z}},getListenerTarget(){let e=S(this.$el);return!window.document||e!==window.document.documentElement&&e!==window.document.body||(e=window),e},getScroll(){const{$el:e,direction:t}=this,i="vertical"===t;let s;if(this.pageMode){const t=e.getBoundingClientRect(),r=i?t.height:t.width;let n=-(i?t.top:t.left),o=i?window.innerHeight:window.innerWidth;n<0&&(o+=n,n=0),n+o>r&&(o=r-n),s={start:n,end:n+o}}else s=i?{start:e.scrollTop,end:e.scrollTop+e.clientHeight}:{start:e.scrollLeft,end:e.scrollLeft+e.clientWidth};return s},applyPageMode(){this.pageMode?this.addListeners():this.removeListeners()},addListeners(){this.listenerTarget=this.getListenerTarget(),this.listenerTarget.addEventListener("scroll",this.handleScroll,!!w&&{passive:!0}),this.listenerTarget.addEventListener("resize",this.handleResize)},removeListeners(){this.listenerTarget&&(this.listenerTarget.removeEventListener("scroll",this.handleScroll),this.listenerTarget.removeEventListener("resize",this.handleResize),this.listenerTarget=null)},scrollToItem(e){let t;const i=this.gridItems||1;t=null===this.itemSize?e>0?this.sizes[e-1].accumulator:0:Math.floor(e/i)*this.itemSize,this.scrollToPosition(t)},scrollToPosition(e){const t="vertical"===this.direction?{scroll:"scrollTop",start:"top"}:{scroll:"scrollLeft",start:"left"};let i,s,r;if(this.pageMode){const n=S(this.$el),o="HTML"===n.tagName?0:n[t.scroll],l=n.getBoundingClientRect(),a=this.$el.getBoundingClientRect()[t.start]-l[t.start];i=n,s=t.scroll,r=e+o+a}else i=this.$el,s=t.scroll,r=e;i[s]=r},itemsLimitError(){throw setTimeout(()=>{console.log("It seems the scroller element isn't scrolling, so it tries to render all the items at once.","Scroller:",this.$el),console.log("Make sure the scroller has a fixed height (or width) and 'overflow-y' (or 'overflow-x') set to 'auto' so it can scroll correctly and only render the items visible in the scroll viewport.")}),new Error("Rendered items limit reached")},sortViews(){this.pool.sort((e,t)=>e.nr.index-t.nr.index)}}};const O={key:0,ref:"before",class:"vue-recycle-scroller__slot"},T={key:1,ref:"after",class:"vue-recycle-scroller__slot"};x.render=function(e,i,s,r,n,o){const l=t.resolveComponent("ResizeObserver"),a=t.resolveDirective("observe-visibility");return t.withDirectives((t.openBlock(),t.createElementBlock("div",{class:t.normalizeClass(["vue-recycle-scroller",{ready:n.ready,"page-mode":s.pageMode,["direction-"+e.direction]:!0}]),onScrollPassive:i[0]||(i[0]=(...e)=>o.handleScroll&&o.handleScroll(...e))},[e.$slots.before?(t.openBlock(),t.createElementBlock("div",O,[t.renderSlot(e.$slots,"before")],512)):t.createCommentVNode("v-if",!0),(t.openBlock(),t.createBlock(t.resolveDynamicComponent(s.listTag),{ref:"wrapper",style:t.normalizeStyle({["vertical"===e.direction?"minHeight":"minWidth"]:n.totalSize+"px"}),class:t.normalizeClass(["vue-recycle-scroller__item-wrapper",s.listClass])},{default:t.withCtx(()=>[(t.openBlock(!0),t.createElementBlock(t.Fragment,null,t.renderList(n.pool,i=>(t.openBlock(),t.createBlock(t.resolveDynamicComponent(s.itemTag),t.mergeProps({key:i.nr.id,style:n.ready?{transform:`translate${"vertical"===e.direction?"Y":"X"}(${i.position}px) translate${"vertical"===e.direction?"X":"Y"}(${i.offset}px)`,width:s.gridItems?("vertical"===e.direction&&s.itemSecondarySize||s.itemSize)+"px":void 0,height:s.gridItems?("horizontal"===e.direction&&s.itemSecondarySize||s.itemSize)+"px":void 0}:null,class:["vue-recycle-scroller__item-view",[s.itemClass,{hover:!s.skipHover&&n.hoverKey===i.nr.key}]]},t.toHandlers(s.skipHover?{}:{mouseenter:()=>{n.hoverKey=i.nr.key},mouseleave:()=>{n.hoverKey=null}})),{default:t.withCtx(()=>[t.renderSlot(e.$slots,"default",{item:i.item,index:i.nr.index,active:i.nr.used})]),_:2},1040,["style","class"]))),128)),t.renderSlot(e.$slots,"empty")]),_:3},8,["style","class"])),e.$slots.after?(t.openBlock(),t.createElementBlock("div",T,[t.renderSlot(e.$slots,"after")],512)):t.createCommentVNode("v-if",!0),t.createVNode(l,{onNotify:o.handleResize},null,8,["onNotify"])],34)),[[a,o.handleVisibilityChange]])},x.__file="src/components/RecycleScroller.vue";var D={name:"DynamicScroller",components:{RecycleScroller:x},provide(){return"undefined"!=typeof ResizeObserver&&(this.$_resizeObserver=new ResizeObserver(e=>{requestAnimationFrame(()=>{if(Array.isArray(e))for(const t of e)if(t.target&&t.target.$_vs_onResize){let e,i;if(t.borderBoxSize){const s=t.borderBoxSize[0];e=s.inlineSize,i=s.blockSize}else e=t.contentRect.width,i=t.contentRect.height;t.target.$_vs_onResize(t.target.$_vs_id,e,i)}})})),{vscrollData:this.vscrollData,vscrollParent:this,vscrollResizeObserver:this.$_resizeObserver}},inheritAttrs:!1,props:{...z,minItemSize:{type:[Number,String],required:!0}},emits:["resize","visible"],data(){return{vscrollData:{active:!0,sizes:{},keyField:this.keyField,simpleArray:!1}}},computed:{simpleArray:_,itemsWithSize(){const e=[],{items:t,keyField:i,simpleArray:s}=this,r=this.vscrollData.sizes,n=t.length;for(let o=0;o<n;o++){const n=t[o],l=s?o:n[i];let a=r[l];void 0!==a||this.$_undefinedMap[l]||(a=0),e.push({item:n,id:l,size:a})}return e}},watch:{items(){this.forceUpdate()},simpleArray:{handler(e){this.vscrollData.simpleArray=e},immediate:!0},direction(e){this.forceUpdate(!0)},itemsWithSize(e,t){const i=this.$el.scrollTop;let s=0,r=0;const n=Math.min(e.length,t.length);for(let o=0;o<n&&!(s>=i);o++)s+=t[o].size||this.minItemSize,r+=e[o].size||this.minItemSize;const o=r-s;0!==o&&(this.$el.scrollTop+=o)}},beforeCreate(){var e;this.$_updates=[],this.$_undefinedSizes=0,this.$_undefinedMap={},this.$_events={all:e=e||new Map,on:function(t,i){var s=e.get(t);s&&s.push(i)||e.set(t,[i])},off:function(t,i){var s=e.get(t);s&&s.splice(s.indexOf(i)>>>0,1)},emit:function(t,i){(e.get(t)||[]).slice().map((function(e){e(i)})),(e.get("*")||[]).slice().map((function(e){e(t,i)}))}}},activated(){this.vscrollData.active=!0},deactivated(){this.vscrollData.active=!1},unmounted(){this.$_events.all.clear()},methods:{onScrollerResize(){this.$refs.scroller&&this.forceUpdate(),this.$emit("resize")},onScrollerVisible(){this.$_events.emit("vscroll:update",{force:!1}),this.$emit("visible")},forceUpdate(e=!1){(e||this.simpleArray)&&(this.vscrollData.sizes={}),this.$_events.emit("vscroll:update",{force:!0})},scrollToItem(e){const t=this.$refs.scroller;t&&t.scrollToItem(e)},getItemSize(e,t){const i=this.simpleArray?null!=t?t:this.items.indexOf(e):e[this.keyField];return this.vscrollData.sizes[i]||0},scrollToBottom(){if(this.$_scrollingToBottom)return;this.$_scrollingToBottom=!0;const e=this.$el;this.$nextTick(()=>{e.scrollTop=e.scrollHeight+5e3;const t=()=>{e.scrollTop=e.scrollHeight+5e3,requestAnimationFrame(()=>{e.scrollTop=e.scrollHeight+5e3,0===this.$_undefinedSizes?this.$_scrollingToBottom=!1:requestAnimationFrame(t)})};requestAnimationFrame(t)})}}};D.render=function(e,i,s,r,n,o){const l=t.resolveComponent("RecycleScroller");return t.openBlock(),t.createBlock(l,t.mergeProps({ref:"scroller",items:o.itemsWithSize,"min-item-size":s.minItemSize,direction:e.direction,"key-field":"id","list-tag":e.listTag,"item-tag":e.itemTag},e.$attrs,{onResize:o.onScrollerResize,onVisible:o.onScrollerVisible}),{default:t.withCtx(({item:i,index:s,active:r})=>[t.renderSlot(e.$slots,"default",t.normalizeProps(t.guardReactiveProps({item:i.item,index:s,active:r,itemWithSize:i})))]),before:t.withCtx(()=>[t.renderSlot(e.$slots,"before")]),after:t.withCtx(()=>[t.renderSlot(e.$slots,"after")]),empty:t.withCtx(()=>[t.renderSlot(e.$slots,"empty")]),_:3},16,["items","min-item-size","direction","list-tag","item-tag","onResize","onVisible"])},D.__file="src/components/DynamicScroller.vue";var R={name:"DynamicScrollerItem",inject:["vscrollData","vscrollParent","vscrollResizeObserver"],props:{item:{required:!0},watchData:{type:Boolean,default:!1},active:{type:Boolean,required:!0},index:{type:Number,default:void 0},sizeDependencies:{type:[Array,Object],default:null},emitResize:{type:Boolean,default:!1},tag:{type:String,default:"div"}},emits:["resize"],computed:{id(){if(this.vscrollData.simpleArray)return this.index;if(this.vscrollData.keyField in this.item)return this.item[this.vscrollData.keyField];throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)},size(){return this.vscrollData.sizes[this.id]||0},finalActive(){return this.active&&this.vscrollData.active}},watch:{watchData:"updateWatchData",id(e,t){if(this.$el.$_vs_id=this.id,this.size||this.onDataUpdate(),this.$_sizeObserved){const i=this.vscrollData.sizes[t],s=this.vscrollData.sizes[e];null!=i&&i!==s&&this.applySize(i)}},finalActive(e){this.size||(e?this.vscrollParent.$_undefinedMap[this.id]||(this.vscrollParent.$_undefinedSizes++,this.vscrollParent.$_undefinedMap[this.id]=!0):this.vscrollParent.$_undefinedMap[this.id]&&(this.vscrollParent.$_undefinedSizes--,this.vscrollParent.$_undefinedMap[this.id]=!1)),this.vscrollResizeObserver?e?this.observeSize():this.unobserveSize():e&&this.$_pendingVScrollUpdate===this.id&&this.updateSize()}},created(){if(!this.$isServer&&(this.$_forceNextVScrollUpdate=null,this.updateWatchData(),!this.vscrollResizeObserver)){for(const e in this.sizeDependencies)this.$watch(()=>this.sizeDependencies[e],this.onDataUpdate);this.vscrollParent.$_events.on("vscroll:update",this.onVscrollUpdate)}},mounted(){this.finalActive&&(this.updateSize(),this.observeSize())},beforeUnmount(){this.vscrollParent.$_events.off("vscroll:update",this.onVscrollUpdate),this.unobserveSize()},methods:{updateSize(){this.finalActive?this.$_pendingSizeUpdate!==this.id&&(this.$_pendingSizeUpdate=this.id,this.$_forceNextVScrollUpdate=null,this.$_pendingVScrollUpdate=null,this.computeSize(this.id)):this.$_forceNextVScrollUpdate=this.id},updateWatchData(){this.watchData&&!this.vscrollResizeObserver?this.$_watchData=this.$watch("item",()=>{this.onDataUpdate()},{deep:!0}):this.$_watchData&&(this.$_watchData(),this.$_watchData=null)},onVscrollUpdate({force:e}){!this.finalActive&&e&&(this.$_pendingVScrollUpdate=this.id),this.$_forceNextVScrollUpdate!==this.id&&!e&&this.size||this.updateSize()},onDataUpdate(){this.updateSize()},computeSize(e){this.$nextTick(()=>{if(this.id===e){const e=this.$el.offsetWidth,t=this.$el.offsetHeight;this.applyWidthHeight(e,t)}this.$_pendingSizeUpdate=null})},applyWidthHeight(e,t){const i=~~("vertical"===this.vscrollParent.direction?t:e);i&&this.size!==i&&this.applySize(i)},applySize(e){this.vscrollParent.$_undefinedMap[this.id]&&(this.vscrollParent.$_undefinedSizes--,this.vscrollParent.$_undefinedMap[this.id]=void 0),this.vscrollData.sizes[this.id]=e,this.emitResize&&this.$emit("resize",this.id)},observeSize(){this.vscrollResizeObserver&&(this.$_sizeObserved||(this.vscrollResizeObserver.observe(this.$el),this.$el.$_vs_id=this.id,this.$el.$_vs_onResize=this.onResize,this.$_sizeObserved=!0))},unobserveSize(){this.vscrollResizeObserver&&this.$_sizeObserved&&(this.vscrollResizeObserver.unobserve(this.$el),this.$el.$_vs_onResize=void 0,this.$_sizeObserved=!1)},onResize(e,t,i){this.id===e&&this.applyWidthHeight(t,i)}},render(){return t.h(this.tag,this.$slots.default())}};R.__file="src/components/DynamicScrollerItem.vue";var V={version:"2.0.0-beta.8",install:function(e,t){var i=Object.assign({},{installComponents:!0,componentsPrefix:""},t);for(var r in i)void 0!==i[r]&&(s[r]=i[r]);i.installComponents&&function(e,t){e.component("".concat(t,"recycle-scroller"),x),e.component("".concat(t,"RecycleScroller"),x),e.component("".concat(t,"dynamic-scroller"),D),e.component("".concat(t,"DynamicScroller"),D),e.component("".concat(t,"dynamic-scroller-item"),R),e.component("".concat(t,"DynamicScrollerItem"),R)}(e,i.componentsPrefix)}};return e.DynamicScroller=D,e.DynamicScrollerItem=R,e.IdState=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},i=e.idProp,s=void 0===i?function(e){return e.item.id}:i,r=t.reactive({});return{data:function(){return{idState:null}},created:function(){var e=this;this.$_id=null,this.$_getId="function"==typeof s?function(){return s.call(e,e)}:function(){return e[s]},this.$watch(this.$_getId,{handler:function(e){var t=this;this.$nextTick((function(){t.$_id=e}))},immediate:!0}),this.$_updateIdState()},beforeUpdate:function(){this.$_updateIdState()},methods:{$_idStateInit:function(e){var t=this.$options.idState;if("function"==typeof t){var i=t.call(this,this);return r[e]=i,this.$_id=e,i}throw new Error("[mixin IdState] Missing `idState` function on component definition.")},$_updateIdState:function(){var e=this.$_getId();null==e&&console.warn("No id found for IdState with idProp: '".concat(s,"'.")),e!==this.$_id&&(r[e]||this.$_idStateInit(e),this.idState=r[e])}}}},e.RecycleScroller=x,e.default=V,Object.defineProperty(e,"__esModule",{value:!0}),e}({},Vue);
 //# sourceMappingURL=vue-virtual-scroller.min.js.map
diff --git a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.min.js.map b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.min.js.map
index 03b98e2..6f11515 100644
--- a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.min.js.map
+++ b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"vue-virtual-scroller.min.js","sources":["../src/config.js","../../../node_modules/.pnpm/vue-resize@2.0.0-alpha.1_vue@3.2.41/node_modules/vue-resize/dist/vue-resize.esm.js","../../../node_modules/.pnpm/vue-observe-visibility@2.0.0-alpha.1_vue@3.2.41/node_modules/vue-observe-visibility/dist/vue-observe-visibility.esm.js","../src/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../../../node_modules/.pnpm/mitt@2.1.0/node_modules/mitt/dist/mitt.es.js","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/index.js","../src/mixins/IdState.js"],"sourcesContent":["export default {\n  itemsLimit: 1000,\n}\n","import { nextTick, pushScopeId, popScopeId, openBlock, createBlock, withScopeId } from 'vue';\n\nfunction getInternetExplorerVersion() {\n  var ua = window.navigator.userAgent;\n  var msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  var trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    var rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  var edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nlet isIE;\n\nfunction initCompat () {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n\n  props: {\n    emitOnMount: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreWidth: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreHeight: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: [\n    'notify',\n  ],\n\n  mounted () {\n    initCompat();\n    nextTick(() => {\n      this._w = this.$el.offsetWidth;\n      this._h = this.$el.offsetHeight;\n      if (this.emitOnMount) {\n        this.emitSize();\n      }\n    });\n    const object = document.createElement('object');\n    this._resizeObject = object;\n    object.setAttribute('aria-hidden', 'true');\n    object.setAttribute('tabindex', -1);\n    object.onload = this.addResizeHandlers;\n    object.type = 'text/html';\n    if (isIE) {\n      this.$el.appendChild(object);\n    }\n    object.data = 'about:blank';\n    if (!isIE) {\n      this.$el.appendChild(object);\n    }\n  },\n\n  beforeUnmount () {\n    this.removeResizeHandlers();\n  },\n\n  methods: {\n    compareAndNotify () {\n      if ((!this.ignoreWidth && this._w !== this.$el.offsetWidth) || (!this.ignoreHeight && this._h !== this.$el.offsetHeight)) {\n        this._w = this.$el.offsetWidth;\n        this._h = this.$el.offsetHeight;\n        this.emitSize();\n      }\n    },\n\n    emitSize () {\n      this.$emit('notify', {\n        width: this._w,\n        height: this._h,\n      });\n    },\n\n    addResizeHandlers () {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);\n      this.compareAndNotify();\n    },\n\n    removeResizeHandlers () {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);\n        }\n        this.$el.removeChild(this._resizeObject);\n        this._resizeObject.onload = null;\n        this._resizeObject = null;\n      }\n    },\n  },\n};\n\nconst _withId = /*#__PURE__*/withScopeId(\"data-v-b329ee4c\");\n\npushScopeId(\"data-v-b329ee4c\");\nconst _hoisted_1 = {\n  class: \"resize-observer\",\n  tabindex: \"-1\"\n};\npopScopeId();\n\nconst render = /*#__PURE__*/_withId((_ctx, _cache, $props, $setup, $data, $options) => {\n  return (openBlock(), createBlock(\"div\", _hoisted_1))\n});\n\nscript.render = render;\nscript.__scopeId = \"data-v-b329ee4c\";\nscript.__file = \"src/components/ResizeObserver.vue\";\n\nfunction install(app) {\n  // eslint-disable-next-line vue/component-definition-name-casing\n  app.component('resize-observer', script);\n  app.component('ResizeObserver', script);\n}\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue-resize.esm.js.map\n","import { nextTick } from 'vue';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState = /*#__PURE__*/function () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && typeof this.options.intersection.threshold === 'number' ? this.options.intersection.threshold : 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction beforeMount(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction updated(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unmounted(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    beforeMount(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unmounted(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  beforeMount: beforeMount,\n  updated: updated,\n  unmounted: unmounted\n};\n\nfunction install(app) {\n  app.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","// Fork of https://github.com/olahol/scrollparent.js to be able to build with Rollup\n\nconst regex = /(auto|scroll)/\n\nfunction parents (node, ps) {\n  if (node.parentNode === null) { return ps }\n\n  return parents(node.parentNode, ps.concat([node]))\n}\n\nconst style = function (node, prop) {\n  return getComputedStyle(node, null).getPropertyValue(prop)\n}\n\nconst overflow = function (node) {\n  return style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x')\n}\n\nconst scroll = function (node) {\n  return regex.test(overflow(node))\n}\n\nexport function getScrollParent (node) {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return\n  }\n\n  const ps = parents(node.parentNode, [])\n\n  for (let i = 0; i < ps.length; i += 1) {\n    if (scroll(ps[i])) {\n      return ps[i]\n    }\n  }\n\n  return document.scrollingElement || document.documentElement\n}\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i&&i.push(e)||n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&i.splice(i.indexOf(e)>>>0,1)},emit:function(t,e){(n.get(t)||[]).slice().map(function(n){n(e)}),(n.get(\"*\")||[]).slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.es.js.map\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<script>\nimport { h } from 'vue'\n\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  emits: [\n    'resize',\n  ],\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField]\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)\n    },\n\n    size () {\n      return this.vscrollData.sizes[this.id] || 0\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id (value, oldValue) {\n      this.$el.$_vs_id = this.id\n      if (!this.size) {\n        this.onDataUpdate()\n      }\n\n      if (this.$_sizeObserved) {\n        // In case the old item had the same size, it won't trigger the ResizeObserver\n        // since we are reusing the same DOM node\n        const oldSize = this.vscrollData.sizes[oldValue]\n        const size = this.vscrollData.sizes[value]\n        if (oldSize != null && oldSize !== size) {\n          this.applySize(oldSize)\n        }\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++\n            this.vscrollParent.$_undefinedMap[this.id] = true\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--\n            this.vscrollParent.$_undefinedMap[this.id] = false\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize()\n        } else {\n          this.unobserveSize()\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize()\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return\n\n    this.$_forceNextVScrollUpdate = null\n    this.updateWatchData()\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\n      }\n\n      this.vscrollParent.$_events.on('vscroll:update', this.onVscrollUpdate)\n    }\n  },\n\n  mounted () {\n    if (this.finalActive) {\n      this.updateSize()\n      this.observeSize()\n    }\n  },\n\n  beforeUnmount () {\n    this.vscrollParent.$_events.off('vscroll:update', this.onVscrollUpdate)\n    this.unobserveSize()\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id\n          this.$_forceNextVScrollUpdate = null\n          this.$_pendingVScrollUpdate = null\n          this.computeSize(this.id)\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate()\n        }, {\n          deep: true,\n        })\n      } else if (this.$_watchData) {\n        this.$_watchData()\n        this.$_watchData = null\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize()\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize()\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth\n          const height = this.$el.offsetHeight\n          this.applyWidthHeight(width, height)\n        }\n        this.$_pendingSizeUpdate = null\n      })\n    },\n\n    applyWidthHeight (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width)\n      if (size && this.size !== size) {\n        this.applySize(size)\n      }\n    },\n\n    applySize (size) {\n      if (this.vscrollParent.$_undefinedMap[this.id]) {\n        this.vscrollParent.$_undefinedSizes--\n        this.vscrollParent.$_undefinedMap[this.id] = undefined\n      }\n      this.vscrollData.sizes[this.id] = size\n      if (this.emitResize) this.$emit('resize', this.id)\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return\n      if (this.$_sizeObserved) return\n      this.vscrollResizeObserver.observe(this.$el)\n      this.$el.$_vs_id = this.id\n      this.$el.$_vs_onResize = this.onResize\n      this.$_sizeObserved = true\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return\n      if (!this.$_sizeObserved) return\n      this.vscrollResizeObserver.unobserve(this.$el)\n      this.$el.$_vs_onResize = undefined\n      this.$_sizeObserved = false\n    },\n\n    onResize (id, width, height) {\n      if (this.id === id) {\n        this.applyWidthHeight(width, height)\n      }\n    },\n  },\n\n  render () {\n    return h(this.tag, this.$slots.default())\n  },\n}\n</script>\n","import config from './config'\n\nimport RecycleScroller from './components/RecycleScroller.vue'\nimport DynamicScroller from './components/DynamicScroller.vue'\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\n\nexport { default as IdState } from './mixins/IdState'\n\nexport {\n  RecycleScroller,\n  DynamicScroller,\n  DynamicScrollerItem,\n}\n\nfunction registerComponents (app, prefix) {\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\n}\n\nconst plugin = {\n  // eslint-disable-next-line no-undef\n  version: VERSION,\n  install (app, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: '',\n    }, options)\n\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key]\n      }\n    }\n\n    if (finalOptions.installComponents) {\n      registerComponents(app, finalOptions.componentsPrefix)\n    }\n  },\n}\n\nexport default plugin\n","import { reactive } from 'vue'\n\nexport default function ({\n  idProp = vm => vm.item.id,\n} = {}) {\n  const store = reactive({})\n\n  // @vue/component\n  return {\n    data () {\n      return {\n        idState: null,\n      }\n    },\n\n    created () {\n      this.$_id = null\n      if (typeof idProp === 'function') {\n        this.$_getId = () => idProp.call(this, this)\n      } else {\n        this.$_getId = () => this[idProp]\n      }\n      this.$watch(this.$_getId, {\n        handler (value) {\n          this.$nextTick(() => {\n            this.$_id = value\n          })\n        },\n        immediate: true,\n      })\n      this.$_updateIdState()\n    },\n\n    beforeUpdate () {\n      this.$_updateIdState()\n    },\n\n    methods: {\n      /**\n       * Initialize an idState\n       * @param {number|string} id Unique id for the data\n       */\n      $_idStateInit (id) {\n        const factory = this.$options.idState\n        if (typeof factory === 'function') {\n          const data = factory.call(this, this)\n          store[id] = data\n          this.$_id = id\n          return data\n        } else {\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\n        }\n      },\n\n      /**\n       * Ensure idState is created and up-to-date\n       */\n      $_updateIdState () {\n        const id = this.$_getId()\n        if (id == null) {\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\n        }\n        if (id !== this.$_id) {\n          if (!store[id]) {\n            this.$_idStateInit(id)\n          }\n          this.idState = store[id]\n        }\n      },\n    },\n  }\n}\n"],"names":["config","itemsLimit","ua","window","navigator","userAgent","msie","indexOf","parseInt","substring","rv","edge","_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_toConsumableArray","arr","Array","isArray","_arrayLikeToArray","_arrayWithoutHoles","iter","from","_iterableToArray","o","minLen","n","toString","call","slice","name","test","_unsupportedIterableToArray","TypeError","_nonIterableSpread","len","arr2","VisibilityState","el","options","vnode","instance","Constructor","_classCallCheck","this","observer","frozen","createObserver","protoProps","staticProps","value","_this","destroyObserver","callback","result","entry","once","throttle","_leading","throttleOptions","leading","delay","timeout","lastState","currentArgs","arguments","undefined","throttled","state","_len","args","_key","apply","concat","clearTimeout","setTimeout","_clear","oldResult","IntersectionObserver","entries","intersectingEntry","find","e","isIntersecting","intersectionRatio","threshold","intersection","nextTick","observe","disconnect","get","beforeMount","_ref2","console","warn","_vue_visibilityState","unmounted","ObserveVisibility","updated","_ref3","deepEqual","val1","val2","oldValue","regex","style","node","prop","getComputedStyle","getPropertyValue","scroll","overflow","getScrollParent","HTMLElement","SVGElement","ps","parents","parentNode","document","scrollingElement","documentElement","items","type","required","keyField","String","default","direction","validator","includes","listTag","itemTag","simpleArray","supportsPassive","opts","addEventListener","uid","script$2","components","ResizeObserver","directives","itemSize","Number","gridItems","itemSecondarySize","minItemSize","sizeField","typeField","buffer","pageMode","Boolean","prerender","emitUpdate","updateInterval","skipHover","listClass","itemClass","emits","data","pool","totalSize","ready","hoverKey","computed","[object Object]","sizes","-1","accumulator","field","current","computedMinSize","l","size","$_computedMinItemSize","watch","updateVisibleItems","applyPageMode","deep","$_startIndex","$_endIndex","$_views","Map","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","error","$nextTick","lastPosition","scrollToPosition","removeListeners","methods","index","item","nr","markRaw","id","used","view","shallowReactive","position","push","fake","unusedViews","unusedPool","set","$emit","event","$_updateTimeout","requestUpdate","requestAnimationFrame","continuous","$_refreshTimout","handleScroll","isVisible","boundingClientRect","width","height","checkItem","checkPositionDiff","count","views","itemIndexByKey","startIndex","endIndex","visibleStartIndex","visibleEndIndex","Math","min","getScroll","positionDiff","start","end","beforeSize","$refs","before","scrollHeight","after","afterSize","h","oldI","a","b","ceil","max","floor","itemsLimitError","unuseView","unusedIndex","v","Error","newlyUsedView","splice","pop","addView","delete","offset","$_sortTimer","sortViews","$el","body","isVertical","scrollState","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","getListenerTarget","passive","handleResize","removeEventListener","viewport","scrollDirection","scrollDistance","viewportEl","tagName","scrollerPosition","log","sort","viewA","viewB","ref","class","_createElementBlock","$data","$props","_ctx","$options","$slots","_openBlock","_hoisted_1","_renderSlot","_createBlock","createBlock","_resolveDynamicComponent","_normalizeStyle","normalizeStyle","_normalizeClass","_Fragment","Fragment","_renderList","_mergeProps","hover","_toHandlers","mouseenter","active","_hoisted_2","_createVNode","_component_ResizeObserver","onNotify","handleVisibilityChange","script$1","RecycleScroller","$_resizeObserver","$_vs_onResize","borderBoxSize","resizeObserverSize","inlineSize","blockSize","contentRect","$_vs_id","vscrollData","vscrollParent","vscrollResizeObserver","inheritAttrs","$_undefinedMap","forceUpdate","immediate","next","prev","prevActiveTop","activeTop","all","$_updates","$_undefinedSizes","$_events","on","handler","handlers","off","emit","evt","map","clear","scroller","force","scrollToItem","$_scrollingToBottom","cb","_component_RecycleScroller","itemsWithSize","min-item-size","key-field","list-tag","item-tag","$attrs","onResize","onScrollerResize","onVisible","onScrollerVisible","itemWithSize","_normalizeProps","_guardReactiveProps","empty","script","inject","watchData","sizeDependencies","emitResize","tag","onDataUpdate","$_sizeObserved","oldSize","applySize","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$watch","onVscrollUpdate","finalActive","$_pendingSizeUpdate","computeSize","$_watchData","offsetWidth","offsetHeight","applyWidthHeight","unobserve","plugin","version","VERSION","install","app","finalOptions","assign","installComponents","componentsPrefix","prefix","component","DynamicScroller","DynamicScrollerItem","registerComponents","_ref","_ref$idProp","idProp","vm","store","reactive","idState","created","$_id","$_getId","_this2","$_updateIdState","beforeUpdate","$_idStateInit","factory"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"vue-virtual-scroller.min.js","sources":["../src/config.js","../../../node_modules/.pnpm/vue-resize@2.0.0-alpha.1_vue@3.2.41/node_modules/vue-resize/dist/vue-resize.esm.js","../../../node_modules/.pnpm/vue-observe-visibility@2.0.0-alpha.1_vue@3.2.41/node_modules/vue-observe-visibility/dist/vue-observe-visibility.esm.js","../src/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../src/components/DynamicScroller.vue","../../../node_modules/.pnpm/mitt@2.1.0/node_modules/mitt/dist/mitt.es.js","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/index.js","../src/mixins/IdState.js"],"sourcesContent":["export default {\n  itemsLimit: 1000,\n}\n","import { nextTick, pushScopeId, popScopeId, openBlock, createBlock, withScopeId } from 'vue';\n\nfunction getInternetExplorerVersion() {\n  var ua = window.navigator.userAgent;\n  var msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  var trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    var rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  var edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nlet isIE;\n\nfunction initCompat () {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n\n  props: {\n    emitOnMount: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreWidth: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreHeight: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: [\n    'notify',\n  ],\n\n  mounted () {\n    initCompat();\n    nextTick(() => {\n      this._w = this.$el.offsetWidth;\n      this._h = this.$el.offsetHeight;\n      if (this.emitOnMount) {\n        this.emitSize();\n      }\n    });\n    const object = document.createElement('object');\n    this._resizeObject = object;\n    object.setAttribute('aria-hidden', 'true');\n    object.setAttribute('tabindex', -1);\n    object.onload = this.addResizeHandlers;\n    object.type = 'text/html';\n    if (isIE) {\n      this.$el.appendChild(object);\n    }\n    object.data = 'about:blank';\n    if (!isIE) {\n      this.$el.appendChild(object);\n    }\n  },\n\n  beforeUnmount () {\n    this.removeResizeHandlers();\n  },\n\n  methods: {\n    compareAndNotify () {\n      if ((!this.ignoreWidth && this._w !== this.$el.offsetWidth) || (!this.ignoreHeight && this._h !== this.$el.offsetHeight)) {\n        this._w = this.$el.offsetWidth;\n        this._h = this.$el.offsetHeight;\n        this.emitSize();\n      }\n    },\n\n    emitSize () {\n      this.$emit('notify', {\n        width: this._w,\n        height: this._h,\n      });\n    },\n\n    addResizeHandlers () {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);\n      this.compareAndNotify();\n    },\n\n    removeResizeHandlers () {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);\n        }\n        this.$el.removeChild(this._resizeObject);\n        this._resizeObject.onload = null;\n        this._resizeObject = null;\n      }\n    },\n  },\n};\n\nconst _withId = /*#__PURE__*/withScopeId(\"data-v-b329ee4c\");\n\npushScopeId(\"data-v-b329ee4c\");\nconst _hoisted_1 = {\n  class: \"resize-observer\",\n  tabindex: \"-1\"\n};\npopScopeId();\n\nconst render = /*#__PURE__*/_withId((_ctx, _cache, $props, $setup, $data, $options) => {\n  return (openBlock(), createBlock(\"div\", _hoisted_1))\n});\n\nscript.render = render;\nscript.__scopeId = \"data-v-b329ee4c\";\nscript.__file = \"src/components/ResizeObserver.vue\";\n\nfunction install(app) {\n  // eslint-disable-next-line vue/component-definition-name-casing\n  app.component('resize-observer', script);\n  app.component('ResizeObserver', script);\n}\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue-resize.esm.js.map\n","import { nextTick } from 'vue';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState = /*#__PURE__*/function () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && typeof this.options.intersection.threshold === 'number' ? this.options.intersection.threshold : 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction beforeMount(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction updated(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unmounted(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    beforeMount(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unmounted(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  beforeMount: beforeMount,\n  updated: updated,\n  unmounted: unmounted\n};\n\nfunction install(app) {\n  app.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","// Fork of https://github.com/olahol/scrollparent.js to be able to build with Rollup\n\nconst regex = /(auto|scroll)/\n\nfunction parents (node, ps) {\n  if (node.parentNode === null) { return ps }\n\n  return parents(node.parentNode, ps.concat([node]))\n}\n\nconst style = function (node, prop) {\n  return getComputedStyle(node, null).getPropertyValue(prop)\n}\n\nconst overflow = function (node) {\n  return style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x')\n}\n\nconst scroll = function (node) {\n  return regex.test(overflow(node))\n}\n\nexport function getScrollParent (node) {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return\n  }\n\n  const ps = parents(node.parentNode, [])\n\n  for (let i = 0; i < ps.length; i += 1) {\n    if (scroll(ps[i])) {\n      return ps[i]\n    }\n  }\n\n  return document.scrollingElement || document.documentElement\n}\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -999999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -999999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i&&i.push(e)||n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&i.splice(i.indexOf(e)>>>0,1)},emit:function(t,e){(n.get(t)||[]).slice().map(function(n){n(e)}),(n.get(\"*\")||[]).slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.es.js.map\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<script>\nimport { h } from 'vue'\n\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  emits: [\n    'resize',\n  ],\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField]\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)\n    },\n\n    size () {\n      return this.vscrollData.sizes[this.id] || 0\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id (value, oldValue) {\n      this.$el.$_vs_id = this.id\n      if (!this.size) {\n        this.onDataUpdate()\n      }\n\n      if (this.$_sizeObserved) {\n        // In case the old item had the same size, it won't trigger the ResizeObserver\n        // since we are reusing the same DOM node\n        const oldSize = this.vscrollData.sizes[oldValue]\n        const size = this.vscrollData.sizes[value]\n        if (oldSize != null && oldSize !== size) {\n          this.applySize(oldSize)\n        }\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++\n            this.vscrollParent.$_undefinedMap[this.id] = true\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--\n            this.vscrollParent.$_undefinedMap[this.id] = false\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize()\n        } else {\n          this.unobserveSize()\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize()\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return\n\n    this.$_forceNextVScrollUpdate = null\n    this.updateWatchData()\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\n      }\n\n      this.vscrollParent.$_events.on('vscroll:update', this.onVscrollUpdate)\n    }\n  },\n\n  mounted () {\n    if (this.finalActive) {\n      this.updateSize()\n      this.observeSize()\n    }\n  },\n\n  beforeUnmount () {\n    this.vscrollParent.$_events.off('vscroll:update', this.onVscrollUpdate)\n    this.unobserveSize()\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id\n          this.$_forceNextVScrollUpdate = null\n          this.$_pendingVScrollUpdate = null\n          this.computeSize(this.id)\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate()\n        }, {\n          deep: true,\n        })\n      } else if (this.$_watchData) {\n        this.$_watchData()\n        this.$_watchData = null\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize()\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize()\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth\n          const height = this.$el.offsetHeight\n          this.applyWidthHeight(width, height)\n        }\n        this.$_pendingSizeUpdate = null\n      })\n    },\n\n    applyWidthHeight (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width)\n      if (size && this.size !== size) {\n        this.applySize(size)\n      }\n    },\n\n    applySize (size) {\n      if (this.vscrollParent.$_undefinedMap[this.id]) {\n        this.vscrollParent.$_undefinedSizes--\n        this.vscrollParent.$_undefinedMap[this.id] = undefined\n      }\n      this.vscrollData.sizes[this.id] = size\n      if (this.emitResize) this.$emit('resize', this.id)\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return\n      if (this.$_sizeObserved) return\n      this.vscrollResizeObserver.observe(this.$el)\n      this.$el.$_vs_id = this.id\n      this.$el.$_vs_onResize = this.onResize\n      this.$_sizeObserved = true\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return\n      if (!this.$_sizeObserved) return\n      this.vscrollResizeObserver.unobserve(this.$el)\n      this.$el.$_vs_onResize = undefined\n      this.$_sizeObserved = false\n    },\n\n    onResize (id, width, height) {\n      if (this.id === id) {\n        this.applyWidthHeight(width, height)\n      }\n    },\n  },\n\n  render () {\n    return h(this.tag, this.$slots.default())\n  },\n}\n</script>\n","import config from './config'\n\nimport RecycleScroller from './components/RecycleScroller.vue'\nimport DynamicScroller from './components/DynamicScroller.vue'\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\n\nexport { default as IdState } from './mixins/IdState'\n\nexport {\n  RecycleScroller,\n  DynamicScroller,\n  DynamicScrollerItem,\n}\n\nfunction registerComponents (app, prefix) {\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\n}\n\nconst plugin = {\n  // eslint-disable-next-line no-undef\n  version: VERSION,\n  install (app, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: '',\n    }, options)\n\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key]\n      }\n    }\n\n    if (finalOptions.installComponents) {\n      registerComponents(app, finalOptions.componentsPrefix)\n    }\n  },\n}\n\nexport default plugin\n","import { reactive } from 'vue'\n\nexport default function ({\n  idProp = vm => vm.item.id,\n} = {}) {\n  const store = reactive({})\n\n  // @vue/component\n  return {\n    data () {\n      return {\n        idState: null,\n      }\n    },\n\n    created () {\n      this.$_id = null\n      if (typeof idProp === 'function') {\n        this.$_getId = () => idProp.call(this, this)\n      } else {\n        this.$_getId = () => this[idProp]\n      }\n      this.$watch(this.$_getId, {\n        handler (value) {\n          this.$nextTick(() => {\n            this.$_id = value\n          })\n        },\n        immediate: true,\n      })\n      this.$_updateIdState()\n    },\n\n    beforeUpdate () {\n      this.$_updateIdState()\n    },\n\n    methods: {\n      /**\n       * Initialize an idState\n       * @param {number|string} id Unique id for the data\n       */\n      $_idStateInit (id) {\n        const factory = this.$options.idState\n        if (typeof factory === 'function') {\n          const data = factory.call(this, this)\n          store[id] = data\n          this.$_id = id\n          return data\n        } else {\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\n        }\n      },\n\n      /**\n       * Ensure idState is created and up-to-date\n       */\n      $_updateIdState () {\n        const id = this.$_getId()\n        if (id == null) {\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\n        }\n        if (id !== this.$_id) {\n          if (!store[id]) {\n            this.$_idStateInit(id)\n          }\n          this.idState = store[id]\n        }\n      },\n    },\n  }\n}\n"],"names":["config","itemsLimit","ua","window","navigator","userAgent","msie","indexOf","parseInt","substring","rv","edge","_typeof","obj","Symbol","iterator","constructor","prototype","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_toConsumableArray","arr","Array","isArray","_arrayLikeToArray","_arrayWithoutHoles","iter","from","_iterableToArray","o","minLen","n","toString","call","slice","name","test","_unsupportedIterableToArray","TypeError","_nonIterableSpread","len","arr2","VisibilityState","el","options","vnode","instance","Constructor","_classCallCheck","this","observer","frozen","createObserver","protoProps","staticProps","value","_this","destroyObserver","callback","result","entry","once","throttle","_leading","throttleOptions","leading","delay","timeout","lastState","currentArgs","arguments","undefined","throttled","state","_len","args","_key","apply","concat","clearTimeout","setTimeout","_clear","oldResult","IntersectionObserver","entries","intersectingEntry","find","e","isIntersecting","intersectionRatio","threshold","intersection","nextTick","observe","disconnect","get","beforeMount","_ref2","console","warn","_vue_visibilityState","unmounted","ObserveVisibility","updated","_ref3","deepEqual","val1","val2","oldValue","regex","style","node","prop","getComputedStyle","getPropertyValue","scroll","overflow","getScrollParent","HTMLElement","SVGElement","ps","parents","parentNode","document","scrollingElement","documentElement","items","type","required","keyField","String","default","direction","validator","includes","listTag","itemTag","simpleArray","supportsPassive","opts","addEventListener","uid","script$2","components","ResizeObserver","directives","itemSize","Number","gridItems","itemSecondarySize","minItemSize","sizeField","typeField","buffer","pageMode","Boolean","prerender","emitUpdate","updateInterval","skipHover","listClass","itemClass","emits","data","pool","totalSize","ready","hoverKey","computed","[object Object]","sizes","-1","accumulator","field","current","computedMinSize","l","size","$_computedMinItemSize","watch","updateVisibleItems","applyPageMode","deep","$_startIndex","$_endIndex","$_views","Map","$_unusedViews","$_scrollDirty","$_lastUpdateScrollPosition","$_prerender","error","$nextTick","lastPosition","scrollToPosition","removeListeners","methods","index","item","nr","markRaw","id","used","view","shallowReactive","position","push","fake","unusedViews","unusedPool","set","$emit","event","$_updateTimeout","requestUpdate","requestAnimationFrame","continuous","$_refreshTimout","handleScroll","isVisible","boundingClientRect","width","height","checkItem","checkPositionDiff","count","views","itemIndexByKey","startIndex","endIndex","visibleStartIndex","visibleEndIndex","Math","min","getScroll","positionDiff","start","end","beforeSize","$refs","before","scrollHeight","after","afterSize","h","oldI","a","b","ceil","max","floor","itemsLimitError","unuseView","unusedIndex","v","Error","newlyUsedView","splice","pop","addView","delete","offset","$_sortTimer","sortViews","$el","body","isVertical","scrollState","bounds","getBoundingClientRect","boundsSize","top","left","innerHeight","innerWidth","scrollTop","clientHeight","scrollLeft","clientWidth","addListeners","listenerTarget","getListenerTarget","passive","handleResize","removeEventListener","viewport","scrollDirection","scrollDistance","viewportEl","tagName","scrollerPosition","log","sort","viewA","viewB","ref","class","_createElementBlock","$data","$props","_ctx","$options","$slots","_openBlock","_hoisted_1","_renderSlot","_createBlock","createBlock","_resolveDynamicComponent","_normalizeStyle","normalizeStyle","_normalizeClass","_Fragment","Fragment","_renderList","_mergeProps","hover","_toHandlers","mouseenter","active","_hoisted_2","_createVNode","_component_ResizeObserver","onNotify","handleVisibilityChange","script$1","RecycleScroller","$_resizeObserver","$_vs_onResize","borderBoxSize","resizeObserverSize","inlineSize","blockSize","contentRect","$_vs_id","vscrollData","vscrollParent","vscrollResizeObserver","inheritAttrs","$_undefinedMap","forceUpdate","immediate","next","prev","prevActiveTop","activeTop","all","$_updates","$_undefinedSizes","$_events","on","handler","handlers","off","emit","evt","map","clear","scroller","force","scrollToItem","$_scrollingToBottom","cb","_component_RecycleScroller","itemsWithSize","min-item-size","key-field","list-tag","item-tag","$attrs","onResize","onScrollerResize","onVisible","onScrollerVisible","itemWithSize","_normalizeProps","_guardReactiveProps","empty","script","inject","watchData","sizeDependencies","emitResize","tag","onDataUpdate","$_sizeObserved","oldSize","applySize","observeSize","unobserveSize","$_pendingVScrollUpdate","updateSize","$isServer","$_forceNextVScrollUpdate","updateWatchData","k","$watch","onVscrollUpdate","finalActive","$_pendingSizeUpdate","computeSize","$_watchData","offsetWidth","offsetHeight","applyWidthHeight","unobserve","plugin","version","VERSION","install","app","finalOptions","assign","installComponents","componentsPrefix","prefix","component","DynamicScroller","DynamicScrollerItem","registerComponents","_ref","_ref$idProp","idProp","vm","store","reactive","idState","created","$_id","$_getId","_this2","$_updateIdState","beforeUpdate","$_idStateInit","factory"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.umd.js b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.umd.js
index fac9e84..f6e9a75 100644
--- a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.umd.js
+++ b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.umd.js
@@ -696,7 +696,7 @@
         unusedPool.push(view);
         if (!fake) {
           view.nr.used = false;
-          view.position = -9999;
+          view.position = -999999;
         }
       },
 
diff --git a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.umd.js.map b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.umd.js.map
index cc25f7d..7701c25 100644
--- a/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.umd.js.map
+++ b/node_modules/vue-virtual-scroller/dist/vue-virtual-scroller.umd.js.map
@@ -1 +1 @@
-{"version":3,"file":"vue-virtual-scroller.umd.js","sources":["../src/config.js","../../../node_modules/.pnpm/vue-resize@2.0.0-alpha.1_vue@3.2.41/node_modules/vue-resize/dist/vue-resize.esm.js","../../../node_modules/.pnpm/vue-observe-visibility@2.0.0-alpha.1_vue@3.2.41/node_modules/vue-observe-visibility/dist/vue-observe-visibility.esm.js","../src/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../../../node_modules/.pnpm/mitt@2.1.0/node_modules/mitt/dist/mitt.es.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/mixins/IdState.js","../src/index.js"],"sourcesContent":["export default {\n  itemsLimit: 1000,\n}\n","import { nextTick, pushScopeId, popScopeId, openBlock, createBlock, withScopeId } from 'vue';\n\nfunction getInternetExplorerVersion() {\n  var ua = window.navigator.userAgent;\n  var msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  var trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    var rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  var edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nlet isIE;\n\nfunction initCompat () {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n\n  props: {\n    emitOnMount: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreWidth: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreHeight: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: [\n    'notify',\n  ],\n\n  mounted () {\n    initCompat();\n    nextTick(() => {\n      this._w = this.$el.offsetWidth;\n      this._h = this.$el.offsetHeight;\n      if (this.emitOnMount) {\n        this.emitSize();\n      }\n    });\n    const object = document.createElement('object');\n    this._resizeObject = object;\n    object.setAttribute('aria-hidden', 'true');\n    object.setAttribute('tabindex', -1);\n    object.onload = this.addResizeHandlers;\n    object.type = 'text/html';\n    if (isIE) {\n      this.$el.appendChild(object);\n    }\n    object.data = 'about:blank';\n    if (!isIE) {\n      this.$el.appendChild(object);\n    }\n  },\n\n  beforeUnmount () {\n    this.removeResizeHandlers();\n  },\n\n  methods: {\n    compareAndNotify () {\n      if ((!this.ignoreWidth && this._w !== this.$el.offsetWidth) || (!this.ignoreHeight && this._h !== this.$el.offsetHeight)) {\n        this._w = this.$el.offsetWidth;\n        this._h = this.$el.offsetHeight;\n        this.emitSize();\n      }\n    },\n\n    emitSize () {\n      this.$emit('notify', {\n        width: this._w,\n        height: this._h,\n      });\n    },\n\n    addResizeHandlers () {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);\n      this.compareAndNotify();\n    },\n\n    removeResizeHandlers () {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);\n        }\n        this.$el.removeChild(this._resizeObject);\n        this._resizeObject.onload = null;\n        this._resizeObject = null;\n      }\n    },\n  },\n};\n\nconst _withId = /*#__PURE__*/withScopeId(\"data-v-b329ee4c\");\n\npushScopeId(\"data-v-b329ee4c\");\nconst _hoisted_1 = {\n  class: \"resize-observer\",\n  tabindex: \"-1\"\n};\npopScopeId();\n\nconst render = /*#__PURE__*/_withId((_ctx, _cache, $props, $setup, $data, $options) => {\n  return (openBlock(), createBlock(\"div\", _hoisted_1))\n});\n\nscript.render = render;\nscript.__scopeId = \"data-v-b329ee4c\";\nscript.__file = \"src/components/ResizeObserver.vue\";\n\nfunction install(app) {\n  // eslint-disable-next-line vue/component-definition-name-casing\n  app.component('resize-observer', script);\n  app.component('ResizeObserver', script);\n}\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue-resize.esm.js.map\n","import { nextTick } from 'vue';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState = /*#__PURE__*/function () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && typeof this.options.intersection.threshold === 'number' ? this.options.intersection.threshold : 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction beforeMount(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction updated(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unmounted(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    beforeMount(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unmounted(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  beforeMount: beforeMount,\n  updated: updated,\n  unmounted: unmounted\n};\n\nfunction install(app) {\n  app.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","// Fork of https://github.com/olahol/scrollparent.js to be able to build with Rollup\n\nconst regex = /(auto|scroll)/\n\nfunction parents (node, ps) {\n  if (node.parentNode === null) { return ps }\n\n  return parents(node.parentNode, ps.concat([node]))\n}\n\nconst style = function (node, prop) {\n  return getComputedStyle(node, null).getPropertyValue(prop)\n}\n\nconst overflow = function (node) {\n  return style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x')\n}\n\nconst scroll = function (node) {\n  return regex.test(overflow(node))\n}\n\nexport function getScrollParent (node) {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return\n  }\n\n  const ps = parents(node.parentNode, [])\n\n  for (let i = 0; i < ps.length; i += 1) {\n    if (scroll(ps[i])) {\n      return ps[i]\n    }\n  }\n\n  return document.scrollingElement || document.documentElement\n}\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -9999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i&&i.push(e)||n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&i.splice(i.indexOf(e)>>>0,1)},emit:function(t,e){(n.get(t)||[]).slice().map(function(n){n(e)}),(n.get(\"*\")||[]).slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.es.js.map\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<script>\nimport { h } from 'vue'\n\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  emits: [\n    'resize',\n  ],\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField]\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)\n    },\n\n    size () {\n      return this.vscrollData.sizes[this.id] || 0\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id (value, oldValue) {\n      this.$el.$_vs_id = this.id\n      if (!this.size) {\n        this.onDataUpdate()\n      }\n\n      if (this.$_sizeObserved) {\n        // In case the old item had the same size, it won't trigger the ResizeObserver\n        // since we are reusing the same DOM node\n        const oldSize = this.vscrollData.sizes[oldValue]\n        const size = this.vscrollData.sizes[value]\n        if (oldSize != null && oldSize !== size) {\n          this.applySize(oldSize)\n        }\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++\n            this.vscrollParent.$_undefinedMap[this.id] = true\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--\n            this.vscrollParent.$_undefinedMap[this.id] = false\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize()\n        } else {\n          this.unobserveSize()\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize()\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return\n\n    this.$_forceNextVScrollUpdate = null\n    this.updateWatchData()\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\n      }\n\n      this.vscrollParent.$_events.on('vscroll:update', this.onVscrollUpdate)\n    }\n  },\n\n  mounted () {\n    if (this.finalActive) {\n      this.updateSize()\n      this.observeSize()\n    }\n  },\n\n  beforeUnmount () {\n    this.vscrollParent.$_events.off('vscroll:update', this.onVscrollUpdate)\n    this.unobserveSize()\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id\n          this.$_forceNextVScrollUpdate = null\n          this.$_pendingVScrollUpdate = null\n          this.computeSize(this.id)\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate()\n        }, {\n          deep: true,\n        })\n      } else if (this.$_watchData) {\n        this.$_watchData()\n        this.$_watchData = null\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize()\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize()\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth\n          const height = this.$el.offsetHeight\n          this.applyWidthHeight(width, height)\n        }\n        this.$_pendingSizeUpdate = null\n      })\n    },\n\n    applyWidthHeight (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width)\n      if (size && this.size !== size) {\n        this.applySize(size)\n      }\n    },\n\n    applySize (size) {\n      if (this.vscrollParent.$_undefinedMap[this.id]) {\n        this.vscrollParent.$_undefinedSizes--\n        this.vscrollParent.$_undefinedMap[this.id] = undefined\n      }\n      this.vscrollData.sizes[this.id] = size\n      if (this.emitResize) this.$emit('resize', this.id)\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return\n      if (this.$_sizeObserved) return\n      this.vscrollResizeObserver.observe(this.$el)\n      this.$el.$_vs_id = this.id\n      this.$el.$_vs_onResize = this.onResize\n      this.$_sizeObserved = true\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return\n      if (!this.$_sizeObserved) return\n      this.vscrollResizeObserver.unobserve(this.$el)\n      this.$el.$_vs_onResize = undefined\n      this.$_sizeObserved = false\n    },\n\n    onResize (id, width, height) {\n      if (this.id === id) {\n        this.applyWidthHeight(width, height)\n      }\n    },\n  },\n\n  render () {\n    return h(this.tag, this.$slots.default())\n  },\n}\n</script>\n","import { reactive } from 'vue'\n\nexport default function ({\n  idProp = vm => vm.item.id,\n} = {}) {\n  const store = reactive({})\n\n  // @vue/component\n  return {\n    data () {\n      return {\n        idState: null,\n      }\n    },\n\n    created () {\n      this.$_id = null\n      if (typeof idProp === 'function') {\n        this.$_getId = () => idProp.call(this, this)\n      } else {\n        this.$_getId = () => this[idProp]\n      }\n      this.$watch(this.$_getId, {\n        handler (value) {\n          this.$nextTick(() => {\n            this.$_id = value\n          })\n        },\n        immediate: true,\n      })\n      this.$_updateIdState()\n    },\n\n    beforeUpdate () {\n      this.$_updateIdState()\n    },\n\n    methods: {\n      /**\n       * Initialize an idState\n       * @param {number|string} id Unique id for the data\n       */\n      $_idStateInit (id) {\n        const factory = this.$options.idState\n        if (typeof factory === 'function') {\n          const data = factory.call(this, this)\n          store[id] = data\n          this.$_id = id\n          return data\n        } else {\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\n        }\n      },\n\n      /**\n       * Ensure idState is created and up-to-date\n       */\n      $_updateIdState () {\n        const id = this.$_getId()\n        if (id == null) {\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\n        }\n        if (id !== this.$_id) {\n          if (!store[id]) {\n            this.$_idStateInit(id)\n          }\n          this.idState = store[id]\n        }\n      },\n    },\n  }\n}\n","import config from './config'\n\nimport RecycleScroller from './components/RecycleScroller.vue'\nimport DynamicScroller from './components/DynamicScroller.vue'\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\n\nexport { default as IdState } from './mixins/IdState'\n\nexport {\n  RecycleScroller,\n  DynamicScroller,\n  DynamicScrollerItem,\n}\n\nfunction registerComponents (app, prefix) {\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\n}\n\nconst plugin = {\n  // eslint-disable-next-line no-undef\n  version: VERSION,\n  install (app, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: '',\n    }, options)\n\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key]\n      }\n    }\n\n    if (finalOptions.installComponents) {\n      registerComponents(app, finalOptions.componentsPrefix)\n    }\n  },\n}\n\nexport default plugin\n"],"names":["itemsLimit","getInternetExplorerVersion","ua","window","navigator","userAgent","msie","indexOf","parseInt","substring","trident","rv","edge","_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","o","minLen","n","toString","call","slice","name","test","len","arr2","processOptions","value","options","callback","throttle","delay","arguments","undefined","timeout","lastState","currentArgs","throttled","state","_len","args","_key","leading","apply","concat","clearTimeout","setTimeout","_clear","deepEqual","val1","val2","VisibilityState","el","vnode","observer","frozen","createObserver","_this","destroyObserver","result","entry","once","_ref","throttleOptions","_leading","oldResult","IntersectionObserver","entries","intersectingEntry","find","e","isIntersecting","intersectionRatio","threshold","intersection","nextTick","observe","disconnect","get","beforeMount","_ref2","console","warn","_vue_visibilityState","updated","_ref3","oldValue","unmounted","ObserveVisibility","regex","parents","node","ps","parentNode","style","prop","getComputedStyle","getPropertyValue","overflow","scroll","getScrollParent","HTMLElement","SVGElement","document","scrollingElement","documentElement","items","type","required","keyField","String","default","direction","validator","includes","listTag","itemTag","simpleArray","supportsPassive","opts","addEventListener","ResizeObserver","markRaw","shallowReactive","_createElementBlock","_openBlock","_renderSlot","_createBlock","_resolveDynamicComponent","_normalizeStyle","_normalizeClass","_Fragment","_renderList","_mergeProps","_toHandlers","_createVNode","all","Map","on","handler","handlers","push","set","off","splice","emit","evt","map","RecycleScroller","_normalizeProps","_guardReactiveProps","h","idProp","vm","item","id","store","reactive","data","idState","created","$_id","$_getId","$watch","$nextTick","immediate","$_updateIdState","beforeUpdate","methods","$_idStateInit","factory","$options","Error","registerComponents","app","prefix","component","DynamicScroller","DynamicScrollerItem","plugin","version","VERSION","install","finalOptions","assign","installComponents","componentsPrefix","config"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"vue-virtual-scroller.umd.js","sources":["../src/config.js","../../../node_modules/.pnpm/vue-resize@2.0.0-alpha.1_vue@3.2.41/node_modules/vue-resize/dist/vue-resize.esm.js","../../../node_modules/.pnpm/vue-observe-visibility@2.0.0-alpha.1_vue@3.2.41/node_modules/vue-observe-visibility/dist/vue-observe-visibility.esm.js","../src/scrollparent.js","../src/components/common.js","../src/utils.js","../src/components/RecycleScroller.vue","../src/components/RecycleScroller.vue?vue&type=template&id=093a936d&lang.js","../../../node_modules/.pnpm/mitt@2.1.0/node_modules/mitt/dist/mitt.es.js","../src/components/DynamicScroller.vue","../src/components/DynamicScroller.vue?vue&type=template&id=76e15f19&lang.js","../src/components/DynamicScrollerItem.vue","../src/mixins/IdState.js","../src/index.js"],"sourcesContent":["export default {\n  itemsLimit: 1000,\n}\n","import { nextTick, pushScopeId, popScopeId, openBlock, createBlock, withScopeId } from 'vue';\n\nfunction getInternetExplorerVersion() {\n  var ua = window.navigator.userAgent;\n  var msie = ua.indexOf('MSIE ');\n\n  if (msie > 0) {\n    // IE 10 or older => return version number\n    return parseInt(ua.substring(msie + 5, ua.indexOf('.', msie)), 10);\n  }\n\n  var trident = ua.indexOf('Trident/');\n\n  if (trident > 0) {\n    // IE 11 => return version number\n    var rv = ua.indexOf('rv:');\n    return parseInt(ua.substring(rv + 3, ua.indexOf('.', rv)), 10);\n  }\n\n  var edge = ua.indexOf('Edge/');\n\n  if (edge > 0) {\n    // Edge (IE 12+) => return version number\n    return parseInt(ua.substring(edge + 5, ua.indexOf('.', edge)), 10);\n  } // other browser\n\n\n  return -1;\n}\n\nlet isIE;\n\nfunction initCompat () {\n  if (!initCompat.init) {\n    initCompat.init = true;\n    isIE = getInternetExplorerVersion() !== -1;\n  }\n}\n\nvar script = {\n  name: 'ResizeObserver',\n\n  props: {\n    emitOnMount: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreWidth: {\n      type: Boolean,\n      default: false,\n    },\n\n    ignoreHeight: {\n      type: Boolean,\n      default: false,\n    },\n  },\n\n  emits: [\n    'notify',\n  ],\n\n  mounted () {\n    initCompat();\n    nextTick(() => {\n      this._w = this.$el.offsetWidth;\n      this._h = this.$el.offsetHeight;\n      if (this.emitOnMount) {\n        this.emitSize();\n      }\n    });\n    const object = document.createElement('object');\n    this._resizeObject = object;\n    object.setAttribute('aria-hidden', 'true');\n    object.setAttribute('tabindex', -1);\n    object.onload = this.addResizeHandlers;\n    object.type = 'text/html';\n    if (isIE) {\n      this.$el.appendChild(object);\n    }\n    object.data = 'about:blank';\n    if (!isIE) {\n      this.$el.appendChild(object);\n    }\n  },\n\n  beforeUnmount () {\n    this.removeResizeHandlers();\n  },\n\n  methods: {\n    compareAndNotify () {\n      if ((!this.ignoreWidth && this._w !== this.$el.offsetWidth) || (!this.ignoreHeight && this._h !== this.$el.offsetHeight)) {\n        this._w = this.$el.offsetWidth;\n        this._h = this.$el.offsetHeight;\n        this.emitSize();\n      }\n    },\n\n    emitSize () {\n      this.$emit('notify', {\n        width: this._w,\n        height: this._h,\n      });\n    },\n\n    addResizeHandlers () {\n      this._resizeObject.contentDocument.defaultView.addEventListener('resize', this.compareAndNotify);\n      this.compareAndNotify();\n    },\n\n    removeResizeHandlers () {\n      if (this._resizeObject && this._resizeObject.onload) {\n        if (!isIE && this._resizeObject.contentDocument) {\n          this._resizeObject.contentDocument.defaultView.removeEventListener('resize', this.compareAndNotify);\n        }\n        this.$el.removeChild(this._resizeObject);\n        this._resizeObject.onload = null;\n        this._resizeObject = null;\n      }\n    },\n  },\n};\n\nconst _withId = /*#__PURE__*/withScopeId(\"data-v-b329ee4c\");\n\npushScopeId(\"data-v-b329ee4c\");\nconst _hoisted_1 = {\n  class: \"resize-observer\",\n  tabindex: \"-1\"\n};\npopScopeId();\n\nconst render = /*#__PURE__*/_withId((_ctx, _cache, $props, $setup, $data, $options) => {\n  return (openBlock(), createBlock(\"div\", _hoisted_1))\n});\n\nscript.render = render;\nscript.__scopeId = \"data-v-b329ee4c\";\nscript.__file = \"src/components/ResizeObserver.vue\";\n\nfunction install(app) {\n  // eslint-disable-next-line vue/component-definition-name-casing\n  app.component('resize-observer', script);\n  app.component('ResizeObserver', script);\n}\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { script as ResizeObserver, install };\n//# sourceMappingURL=vue-resize.esm.js.map\n","import { nextTick } from 'vue';\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nfunction _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\n\n  return arr2;\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction processOptions(value) {\n  var options;\n\n  if (typeof value === 'function') {\n    // Simple options (callback-only)\n    options = {\n      callback: value\n    };\n  } else {\n    // Options object\n    options = value;\n  }\n\n  return options;\n}\nfunction throttle(callback, delay) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var timeout;\n  var lastState;\n  var currentArgs;\n\n  var throttled = function throttled(state) {\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    currentArgs = args;\n    if (timeout && state === lastState) return;\n    var leading = options.leading;\n\n    if (typeof leading === 'function') {\n      leading = leading(state, lastState);\n    }\n\n    if ((!timeout || state !== lastState) && leading) {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n    }\n\n    lastState = state;\n    clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      callback.apply(void 0, [state].concat(_toConsumableArray(currentArgs)));\n      timeout = 0;\n    }, delay);\n  };\n\n  throttled._clear = function () {\n    clearTimeout(timeout);\n    timeout = null;\n  };\n\n  return throttled;\n}\nfunction deepEqual(val1, val2) {\n  if (val1 === val2) return true;\n\n  if (_typeof(val1) === 'object') {\n    for (var key in val1) {\n      if (!deepEqual(val1[key], val2[key])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  return false;\n}\n\nvar VisibilityState = /*#__PURE__*/function () {\n  function VisibilityState(el, options, vnode) {\n    _classCallCheck(this, VisibilityState);\n\n    this.el = el;\n    this.observer = null;\n    this.frozen = false;\n    this.createObserver(options, vnode);\n  }\n\n  _createClass(VisibilityState, [{\n    key: \"createObserver\",\n    value: function createObserver(options, vnode) {\n      var _this = this;\n\n      if (this.observer) {\n        this.destroyObserver();\n      }\n\n      if (this.frozen) return;\n      this.options = processOptions(options);\n\n      this.callback = function (result, entry) {\n        _this.options.callback(result, entry);\n\n        if (result && _this.options.once) {\n          _this.frozen = true;\n\n          _this.destroyObserver();\n        }\n      }; // Throttle\n\n\n      if (this.callback && this.options.throttle) {\n        var _ref = this.options.throttleOptions || {},\n            _leading = _ref.leading;\n\n        this.callback = throttle(this.callback, this.options.throttle, {\n          leading: function leading(state) {\n            return _leading === 'both' || _leading === 'visible' && state || _leading === 'hidden' && !state;\n          }\n        });\n      }\n\n      this.oldResult = undefined;\n      this.observer = new IntersectionObserver(function (entries) {\n        var entry = entries[0];\n\n        if (entries.length > 1) {\n          var intersectingEntry = entries.find(function (e) {\n            return e.isIntersecting;\n          });\n\n          if (intersectingEntry) {\n            entry = intersectingEntry;\n          }\n        }\n\n        if (_this.callback) {\n          // Use isIntersecting if possible because browsers can report isIntersecting as true, but intersectionRatio as 0, when something very slowly enters the viewport.\n          var result = entry.isIntersecting && entry.intersectionRatio >= _this.threshold;\n          if (result === _this.oldResult) return;\n          _this.oldResult = result;\n\n          _this.callback(result, entry);\n        }\n      }, this.options.intersection); // Wait for the element to be in document\n\n      nextTick(function () {\n        if (_this.observer) {\n          _this.observer.observe(_this.el);\n        }\n      });\n    }\n  }, {\n    key: \"destroyObserver\",\n    value: function destroyObserver() {\n      if (this.observer) {\n        this.observer.disconnect();\n        this.observer = null;\n      } // Cancel throttled call\n\n\n      if (this.callback && this.callback._clear) {\n        this.callback._clear();\n\n        this.callback = null;\n      }\n    }\n  }, {\n    key: \"threshold\",\n    get: function get() {\n      return this.options.intersection && typeof this.options.intersection.threshold === 'number' ? this.options.intersection.threshold : 0;\n    }\n  }]);\n\n  return VisibilityState;\n}();\n\nfunction beforeMount(el, _ref2, vnode) {\n  var value = _ref2.value;\n  if (!value) return;\n\n  if (typeof IntersectionObserver === 'undefined') {\n    console.warn('[vue-observe-visibility] IntersectionObserver API is not available in your browser. Please install this polyfill: https://github.com/w3c/IntersectionObserver/tree/master/polyfill');\n  } else {\n    var state = new VisibilityState(el, value, vnode);\n    el._vue_visibilityState = state;\n  }\n}\n\nfunction updated(el, _ref3, vnode) {\n  var value = _ref3.value,\n      oldValue = _ref3.oldValue;\n  if (deepEqual(value, oldValue)) return;\n  var state = el._vue_visibilityState;\n\n  if (!value) {\n    unmounted(el);\n    return;\n  }\n\n  if (state) {\n    state.createObserver(value, vnode);\n  } else {\n    beforeMount(el, {\n      value: value\n    }, vnode);\n  }\n}\n\nfunction unmounted(el) {\n  var state = el._vue_visibilityState;\n\n  if (state) {\n    state.destroyObserver();\n    delete el._vue_visibilityState;\n  }\n}\n\nvar ObserveVisibility = {\n  beforeMount: beforeMount,\n  updated: updated,\n  unmounted: unmounted\n};\n\nfunction install(app) {\n  app.directive('observe-visibility', ObserveVisibility);\n  /* -- Add more components here -- */\n}\n/* -- Plugin definition & Auto-install -- */\n\n/* You shouldn't have to modify the code below */\n// Plugin\n\nvar plugin = {\n  // eslint-disable-next-line no-undef\n  version: \"2.0.0-alpha.1\",\n  install: install\n};\n\nexport default plugin;\nexport { ObserveVisibility, install };\n","// Fork of https://github.com/olahol/scrollparent.js to be able to build with Rollup\n\nconst regex = /(auto|scroll)/\n\nfunction parents (node, ps) {\n  if (node.parentNode === null) { return ps }\n\n  return parents(node.parentNode, ps.concat([node]))\n}\n\nconst style = function (node, prop) {\n  return getComputedStyle(node, null).getPropertyValue(prop)\n}\n\nconst overflow = function (node) {\n  return style(node, 'overflow') + style(node, 'overflow-y') + style(node, 'overflow-x')\n}\n\nconst scroll = function (node) {\n  return regex.test(overflow(node))\n}\n\nexport function getScrollParent (node) {\n  if (!(node instanceof HTMLElement || node instanceof SVGElement)) {\n    return\n  }\n\n  const ps = parents(node.parentNode, [])\n\n  for (let i = 0; i < ps.length; i += 1) {\n    if (scroll(ps[i])) {\n      return ps[i]\n    }\n  }\n\n  return document.scrollingElement || document.documentElement\n}\n","export const props = {\n  items: {\n    type: Array,\n    required: true,\n  },\n\n  keyField: {\n    type: String,\n    default: 'id',\n  },\n\n  direction: {\n    type: String,\n    default: 'vertical',\n    validator: (value) => ['vertical', 'horizontal'].includes(value),\n  },\n\n  listTag: {\n    type: String,\n    default: 'div',\n  },\n\n  itemTag: {\n    type: String,\n    default: 'div',\n  },\n}\n\nexport function simpleArray () {\n  return this.items.length && typeof this.items[0] !== 'object'\n}\n","export let supportsPassive = false\n\nif (typeof window !== 'undefined') {\n  supportsPassive = false\n  try {\n    const opts = Object.defineProperty({}, 'passive', {\n      get () {\n        supportsPassive = true\n      },\n    })\n    window.addEventListener('test', null, opts)\n  } catch (e) {}\n}\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -999999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","<template>\n  <div\n    v-observe-visibility=\"handleVisibilityChange\"\n    class=\"vue-recycle-scroller\"\n    :class=\"{\n      ready,\n      'page-mode': pageMode,\n      [`direction-${direction}`]: true,\n    }\"\n    @scroll.passive=\"handleScroll\"\n  >\n    <div\n      v-if=\"$slots.before\"\n      ref=\"before\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"before\"\n      />\n    </div>\n\n    <component\n      :is=\"listTag\"\n      ref=\"wrapper\"\n      :style=\"{ [direction === 'vertical' ? 'minHeight' : 'minWidth']: totalSize + 'px' }\"\n      class=\"vue-recycle-scroller__item-wrapper\"\n      :class=\"listClass\"\n    >\n      <component\n        :is=\"itemTag\"\n        v-for=\"view of pool\"\n        :key=\"view.nr.id\"\n        :style=\"ready ? {\n          transform: `translate${direction === 'vertical' ? 'Y' : 'X'}(${view.position}px) translate${direction === 'vertical' ? 'X' : 'Y'}(${view.offset}px)`,\n          width: gridItems ? `${direction === 'vertical' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n          height: gridItems ? `${direction === 'horizontal' ? itemSecondarySize || itemSize : itemSize}px` : undefined,\n        } : null\"\n        class=\"vue-recycle-scroller__item-view\"\n        :class=\"[\n          itemClass,\n          {\n            hover: !skipHover && hoverKey === view.nr.key\n          },\n        ]\"\n        v-on=\"skipHover ? {} : {\n          mouseenter: () => { hoverKey = view.nr.key },\n          mouseleave: () => { hoverKey = null },\n        }\"\n      >\n        <slot\n          :item=\"view.item\"\n          :index=\"view.nr.index\"\n          :active=\"view.nr.used\"\n        />\n      </component>\n\n      <slot\n        name=\"empty\"\n      />\n    </component>\n\n    <div\n      v-if=\"$slots.after\"\n      ref=\"after\"\n      class=\"vue-recycle-scroller__slot\"\n    >\n      <slot\n        name=\"after\"\n      />\n    </div>\n\n    <ResizeObserver @notify=\"handleResize\" />\n  </div>\n</template>\n\n<script>\nimport { shallowReactive, markRaw } from 'vue'\nimport { ResizeObserver } from 'vue-resize'\nimport { ObserveVisibility } from 'vue-observe-visibility'\nimport { getScrollParent } from '../scrollparent'\nimport config from '../config'\nimport { props, simpleArray } from './common'\nimport { supportsPassive } from '../utils'\n\nlet uid = 0\n\nexport default {\n  name: 'RecycleScroller',\n\n  components: {\n    ResizeObserver,\n  },\n\n  directives: {\n    ObserveVisibility,\n  },\n\n  props: {\n    ...props,\n\n    itemSize: {\n      type: Number,\n      default: null,\n    },\n\n    gridItems: {\n      type: Number,\n      default: undefined,\n    },\n\n    itemSecondarySize: {\n      type: Number,\n      default: undefined,\n    },\n\n    minItemSize: {\n      type: [Number, String],\n      default: null,\n    },\n\n    sizeField: {\n      type: String,\n      default: 'size',\n    },\n\n    typeField: {\n      type: String,\n      default: 'type',\n    },\n\n    buffer: {\n      type: Number,\n      default: 200,\n    },\n\n    pageMode: {\n      type: Boolean,\n      default: false,\n    },\n\n    prerender: {\n      type: Number,\n      default: 0,\n    },\n\n    emitUpdate: {\n      type: Boolean,\n      default: false,\n    },\n\n    updateInterval: {\n      type: Number,\n      default: 0,\n    },\n\n    skipHover: {\n      type: Boolean,\n      default: false,\n    },\n\n    listTag: {\n      type: String,\n      default: 'div',\n    },\n\n    itemTag: {\n      type: String,\n      default: 'div',\n    },\n\n    listClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n\n    itemClass: {\n      type: [String, Object, Array],\n      default: '',\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n    'hidden',\n    'update',\n    'scroll-start',\n    'scroll-end',\n  ],\n\n  data () {\n    return {\n      pool: [],\n      totalSize: 0,\n      ready: false,\n      hoverKey: null,\n    }\n  },\n\n  computed: {\n    sizes () {\n      if (this.itemSize === null) {\n        const sizes = {\n          '-1': { accumulator: 0 },\n        }\n        const items = this.items\n        const field = this.sizeField\n        const minItemSize = this.minItemSize\n        let computedMinSize = 10000\n        let accumulator = 0\n        let current\n        for (let i = 0, l = items.length; i < l; i++) {\n          current = items[i][field] || minItemSize\n          if (current < computedMinSize) {\n            computedMinSize = current\n          }\n          accumulator += current\n          sizes[i] = { accumulator, size: current }\n        }\n        // eslint-disable-next-line\n        this.$_computedMinItemSize = computedMinSize\n        return sizes\n      }\n      return []\n    },\n\n    simpleArray,\n\n    itemIndexByKey () {\n      const { keyField, items } = this\n      const result = {}\n      for (let i = 0, l = items.length; i < l; i++) {\n        result[items[i][keyField]] = i\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.updateVisibleItems(true)\n    },\n\n    pageMode () {\n      this.applyPageMode()\n      this.updateVisibleItems(false)\n    },\n\n    sizes: {\n      handler () {\n        this.updateVisibleItems(false)\n      },\n      deep: true,\n    },\n\n    gridItems () {\n      this.updateVisibleItems(true)\n    },\n\n    itemSecondarySize () {\n      this.updateVisibleItems(true)\n    },\n  },\n\n  created () {\n    this.$_startIndex = 0\n    this.$_endIndex = 0\n    this.$_views = new Map()\n    this.$_unusedViews = new Map()\n    this.$_scrollDirty = false\n    this.$_lastUpdateScrollPosition = 0\n\n    // In SSR mode, we also prerender the same number of item for the first render\n    // to avoir mismatch between server and client templates\n    if (this.prerender) {\n      this.$_prerender = true\n      this.updateVisibleItems(false)\n    }\n\n    if (this.gridItems && !this.itemSize) {\n      console.error('[vue-recycle-scroller] You must provide an itemSize when using gridItems')\n    }\n  },\n\n  mounted () {\n    this.applyPageMode()\n    this.$nextTick(() => {\n      // In SSR mode, render the real number of visible items\n      this.$_prerender = false\n      this.updateVisibleItems(true)\n      this.ready = true\n    })\n  },\n\n  activated () {\n    const lastPosition = this.$_lastUpdateScrollPosition\n    if (typeof lastPosition === 'number') {\n      this.$nextTick(() => {\n        this.scrollToPosition(lastPosition)\n      })\n    }\n  },\n\n  beforeUnmount () {\n    this.removeListeners()\n  },\n\n  methods: {\n    addView (pool, index, item, key, type) {\n      const nr = markRaw({\n        id: uid++,\n        index,\n        used: true,\n        key,\n        type,\n      })\n      const view = shallowReactive({\n        item,\n        position: 0,\n        nr,\n      })\n      pool.push(view)\n      return view\n    },\n\n    unuseView (view, fake = false) {\n      const unusedViews = this.$_unusedViews\n      const type = view.nr.type\n      let unusedPool = unusedViews.get(type)\n      if (!unusedPool) {\n        unusedPool = []\n        unusedViews.set(type, unusedPool)\n      }\n      unusedPool.push(view)\n      if (!fake) {\n        view.nr.used = false\n        view.position = -999999\n      }\n    },\n\n    handleResize () {\n      this.$emit('resize')\n      if (this.ready) this.updateVisibleItems(false)\n    },\n\n    handleScroll (event) {\n      if (!this.$_scrollDirty) {\n        this.$_scrollDirty = true\n        if (this.$_updateTimeout) return\n\n        const requestUpdate = () => requestAnimationFrame(() => {\n          this.$_scrollDirty = false\n          const { continuous } = this.updateVisibleItems(false, true)\n\n          // It seems sometimes chrome doesn't fire scroll event :/\n          // When non continous scrolling is ending, we force a refresh\n          if (!continuous) {\n            clearTimeout(this.$_refreshTimout)\n            this.$_refreshTimout = setTimeout(this.handleScroll, this.updateInterval + 100)\n          }\n        })\n\n        requestUpdate()\n\n        // Schedule the next update with throttling\n        if (this.updateInterval) {\n          this.$_updateTimeout = setTimeout(() => {\n            this.$_updateTimeout = 0\n            if (this.$_scrollDirty) requestUpdate()\n          }, this.updateInterval)\n        }\n      }\n    },\n\n    handleVisibilityChange (isVisible, entry) {\n      if (this.ready) {\n        if (isVisible || entry.boundingClientRect.width !== 0 || entry.boundingClientRect.height !== 0) {\n          this.$emit('visible')\n          requestAnimationFrame(() => {\n            this.updateVisibleItems(false)\n          })\n        } else {\n          this.$emit('hidden')\n        }\n      }\n    },\n\n    updateVisibleItems (checkItem, checkPositionDiff = false) {\n      const itemSize = this.itemSize\n      const gridItems = this.gridItems || 1\n      const itemSecondarySize = this.itemSecondarySize || itemSize\n      const minItemSize = this.$_computedMinItemSize\n      const typeField = this.typeField\n      const keyField = this.simpleArray ? null : this.keyField\n      const items = this.items\n      const count = items.length\n      const sizes = this.sizes\n      const views = this.$_views\n      const unusedViews = this.$_unusedViews\n      const pool = this.pool\n      const itemIndexByKey = this.itemIndexByKey\n      let startIndex, endIndex\n      let totalSize\n      let visibleStartIndex, visibleEndIndex\n\n      if (!count) {\n        startIndex = endIndex = visibleStartIndex = visibleEndIndex = totalSize = 0\n      } else if (this.$_prerender) {\n        startIndex = visibleStartIndex = 0\n        endIndex = visibleEndIndex = Math.min(this.prerender, items.length)\n        totalSize = null\n      } else {\n        const scroll = this.getScroll()\n\n        // Skip update if use hasn't scrolled enough\n        if (checkPositionDiff) {\n          let positionDiff = scroll.start - this.$_lastUpdateScrollPosition\n          if (positionDiff < 0) positionDiff = -positionDiff\n          if ((itemSize === null && positionDiff < minItemSize) || positionDiff < itemSize) {\n            return {\n              continuous: true,\n            }\n          }\n        }\n        this.$_lastUpdateScrollPosition = scroll.start\n\n        const buffer = this.buffer\n        scroll.start -= buffer\n        scroll.end += buffer\n\n        // account for leading slot\n        let beforeSize = 0\n        if (this.$refs.before) {\n          beforeSize = this.$refs.before.scrollHeight\n          scroll.start -= beforeSize\n        }\n\n        // account for trailing slot\n        if (this.$refs.after) {\n          const afterSize = this.$refs.after.scrollHeight\n          scroll.end += afterSize\n        }\n\n        // Variable size mode\n        if (itemSize === null) {\n          let h\n          let a = 0\n          let b = count - 1\n          let i = ~~(count / 2)\n          let oldI\n\n          // Searching for startIndex\n          do {\n            oldI = i\n            h = sizes[i].accumulator\n            if (h < scroll.start) {\n              a = i\n            } else if (i < count - 1 && sizes[i + 1].accumulator > scroll.start) {\n              b = i\n            }\n            i = ~~((a + b) / 2)\n          } while (i !== oldI)\n          i < 0 && (i = 0)\n          startIndex = i\n\n          // For container style\n          totalSize = sizes[count - 1].accumulator\n\n          // Searching for endIndex\n          for (endIndex = i; endIndex < count && sizes[endIndex].accumulator < scroll.end; endIndex++);\n          if (endIndex === -1) {\n            endIndex = items.length - 1\n          } else {\n            endIndex++\n            // Bounds\n            endIndex > count && (endIndex = count)\n          }\n\n          // search visible startIndex\n          for (visibleStartIndex = startIndex; visibleStartIndex < count && (beforeSize + sizes[visibleStartIndex].accumulator) < scroll.start; visibleStartIndex++);\n\n          // search visible endIndex\n          for (visibleEndIndex = visibleStartIndex; visibleEndIndex < count && (beforeSize + sizes[visibleEndIndex].accumulator) < scroll.end; visibleEndIndex++);\n        } else {\n          // Fixed size mode\n          startIndex = ~~(scroll.start / itemSize * gridItems)\n          const remainer = startIndex % gridItems\n          startIndex -= remainer\n          endIndex = Math.ceil(scroll.end / itemSize * gridItems)\n          visibleStartIndex = Math.max(0, Math.floor((scroll.start - beforeSize) / itemSize * gridItems))\n          visibleEndIndex = Math.floor((scroll.end - beforeSize) / itemSize * gridItems)\n\n          // Bounds\n          startIndex < 0 && (startIndex = 0)\n          endIndex > count && (endIndex = count)\n          visibleStartIndex < 0 && (visibleStartIndex = 0)\n          visibleEndIndex > count && (visibleEndIndex = count)\n\n          totalSize = Math.ceil(count / gridItems) * itemSize\n        }\n      }\n\n      if (endIndex - startIndex > config.itemsLimit) {\n        this.itemsLimitError()\n      }\n\n      this.totalSize = totalSize\n\n      let view\n\n      const continuous = startIndex <= this.$_endIndex && endIndex >= this.$_startIndex\n\n      // Unuse views that are no longer visible\n      if (continuous) {\n        for (let i = 0, l = pool.length; i < l; i++) {\n          view = pool[i]\n          if (view.nr.used) {\n            // Update view item index\n            if (checkItem) {\n              view.nr.index = itemIndexByKey[view.item[keyField]]\n            }\n\n            // Check if index is still in visible range\n            if (\n              view.nr.index == null ||\n              view.nr.index < startIndex ||\n              view.nr.index >= endIndex\n            ) {\n              this.unuseView(view)\n            }\n          }\n        }\n      }\n\n      const unusedIndex = continuous ? null : new Map()\n\n      let item, type\n      let v\n      for (let i = startIndex; i < endIndex; i++) {\n        item = items[i]\n        const key = keyField ? item[keyField] : item\n        if (key == null) {\n          throw new Error(`Key is ${key} on item (keyField is '${keyField}')`)\n        }\n        view = views.get(key)\n\n        if (!itemSize && !sizes[i].size) {\n          if (view) this.unuseView(view)\n          continue\n        }\n\n        type = item[typeField]\n\n        let unusedPool = unusedViews.get(type)\n        let newlyUsedView = false\n\n        // No view assigned to item\n        if (!view) {\n          if (continuous) {\n            // Reuse existing view\n            if (unusedPool && unusedPool.length) {\n              view = unusedPool.pop()\n            } else {\n              view = this.addView(pool, i, item, key, type)\n            }\n          } else {\n            // Use existing view\n            // We don't care if they are already used\n            // because we are not in continous scrolling\n            v = unusedIndex.get(type) || 0\n\n            if (!unusedPool || v >= unusedPool.length) {\n              view = this.addView(pool, i, item, key, type)\n              this.unuseView(view, true)\n              unusedPool = unusedViews.get(type)\n            }\n\n            view = unusedPool[v]\n            unusedIndex.set(type, v + 1)\n          }\n\n          // Assign view to item\n          views.delete(view.nr.key)\n          view.nr.used = true\n          view.nr.index = i\n          view.nr.key = key\n          view.nr.type = type\n          views.set(key, view)\n\n          newlyUsedView = true\n        } else {\n          // View already assigned to item\n          if (!view.nr.used) {\n            view.nr.used = true\n            newlyUsedView = true\n            if (unusedPool) {\n              const index = unusedPool.indexOf(view)\n              if (index !== -1) unusedPool.splice(index, 1)\n            }\n          }\n        }\n\n        // Always set item in case it's a new object with the same key\n        view.item = item\n\n        if (newlyUsedView) {\n          if (i === items.length - 1) this.$emit('scroll-end')\n          if (i === 0) this.$emit('scroll-start')\n        }\n\n        // Update position\n        if (itemSize === null) {\n          view.position = sizes[i - 1].accumulator\n          view.offset = 0\n        } else {\n          view.position = Math.floor(i / gridItems) * itemSize\n          view.offset = (i % gridItems) * itemSecondarySize\n        }\n      }\n\n      this.$_startIndex = startIndex\n      this.$_endIndex = endIndex\n\n      if (this.emitUpdate) this.$emit('update', startIndex, endIndex, visibleStartIndex, visibleEndIndex)\n\n      // After the user has finished scrolling\n      // Sort views so text selection is correct\n      clearTimeout(this.$_sortTimer)\n      this.$_sortTimer = setTimeout(this.sortViews, this.updateInterval + 300)\n\n      return {\n        continuous,\n      }\n    },\n\n    getListenerTarget () {\n      let target = getScrollParent(this.$el)\n      // Fix global scroll target for Chrome and Safari\n      if (window.document && (target === window.document.documentElement || target === window.document.body)) {\n        target = window\n      }\n      return target\n    },\n\n    getScroll () {\n      const { $el: el, direction } = this\n      const isVertical = direction === 'vertical'\n      let scrollState\n\n      if (this.pageMode) {\n        const bounds = el.getBoundingClientRect()\n        const boundsSize = isVertical ? bounds.height : bounds.width\n        let start = -(isVertical ? bounds.top : bounds.left)\n        let size = isVertical ? window.innerHeight : window.innerWidth\n        if (start < 0) {\n          size += start\n          start = 0\n        }\n        if (start + size > boundsSize) {\n          size = boundsSize - start\n        }\n        scrollState = {\n          start,\n          end: start + size,\n        }\n      } else if (isVertical) {\n        scrollState = {\n          start: el.scrollTop,\n          end: el.scrollTop + el.clientHeight,\n        }\n      } else {\n        scrollState = {\n          start: el.scrollLeft,\n          end: el.scrollLeft + el.clientWidth,\n        }\n      }\n\n      return scrollState\n    },\n\n    applyPageMode () {\n      if (this.pageMode) {\n        this.addListeners()\n      } else {\n        this.removeListeners()\n      }\n    },\n\n    addListeners () {\n      this.listenerTarget = this.getListenerTarget()\n      this.listenerTarget.addEventListener('scroll', this.handleScroll, supportsPassive\n        ? {\n            passive: true,\n          }\n        : false)\n      this.listenerTarget.addEventListener('resize', this.handleResize)\n    },\n\n    removeListeners () {\n      if (!this.listenerTarget) {\n        return\n      }\n\n      this.listenerTarget.removeEventListener('scroll', this.handleScroll)\n      this.listenerTarget.removeEventListener('resize', this.handleResize)\n\n      this.listenerTarget = null\n    },\n\n    scrollToItem (index) {\n      let scroll\n      const gridItems = this.gridItems || 1\n      if (this.itemSize === null) {\n        scroll = index > 0 ? this.sizes[index - 1].accumulator : 0\n      } else {\n        scroll = Math.floor(index / gridItems) * this.itemSize\n      }\n      this.scrollToPosition(scroll)\n    },\n\n    scrollToPosition (position) {\n      const direction = this.direction === 'vertical'\n        ? { scroll: 'scrollTop', start: 'top' }\n        : { scroll: 'scrollLeft', start: 'left' }\n\n      let viewport\n      let scrollDirection\n      let scrollDistance\n\n      if (this.pageMode) {\n        const viewportEl = getScrollParent(this.$el)\n        // HTML doesn't overflow like other elements\n        const scrollTop = viewportEl.tagName === 'HTML' ? 0 : viewportEl[direction.scroll]\n        const bounds = viewportEl.getBoundingClientRect()\n\n        const scroller = this.$el.getBoundingClientRect()\n        const scrollerPosition = scroller[direction.start] - bounds[direction.start]\n\n        viewport = viewportEl\n        scrollDirection = direction.scroll\n        scrollDistance = position + scrollTop + scrollerPosition\n      } else {\n        viewport = this.$el\n        scrollDirection = direction.scroll\n        scrollDistance = position\n      }\n\n      viewport[scrollDirection] = scrollDistance\n    },\n\n    itemsLimitError () {\n      setTimeout(() => {\n        console.log('It seems the scroller element isn\\'t scrolling, so it tries to render all the items at once.', 'Scroller:', this.$el)\n        console.log('Make sure the scroller has a fixed height (or width) and \\'overflow-y\\' (or \\'overflow-x\\') set to \\'auto\\' so it can scroll correctly and only render the items visible in the scroll viewport.')\n      })\n      throw new Error('Rendered items limit reached')\n    },\n\n    sortViews () {\n      this.pool.sort((viewA, viewB) => viewA.nr.index - viewB.nr.index)\n    },\n  },\n}\n</script>\n\n<style>\n.vue-recycle-scroller {\n  position: relative;\n}\n\n.vue-recycle-scroller.direction-vertical:not(.page-mode) {\n  overflow-y: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal:not(.page-mode) {\n  overflow-x: auto;\n}\n\n.vue-recycle-scroller.direction-horizontal {\n  display: flex;\n}\n\n.vue-recycle-scroller__slot {\n  flex: auto 0 0;\n}\n\n.vue-recycle-scroller__item-wrapper {\n  flex: 1;\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n}\n\n.vue-recycle-scroller.ready .vue-recycle-scroller__item-view {\n  position: absolute;\n  top: 0;\n  left: 0;\n  will-change: transform;\n}\n\n.vue-recycle-scroller.direction-vertical .vue-recycle-scroller__item-wrapper {\n  width: 100%;\n}\n\n.vue-recycle-scroller.direction-horizontal .vue-recycle-scroller__item-wrapper {\n  height: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-vertical .vue-recycle-scroller__item-view {\n  width: 100%;\n}\n\n.vue-recycle-scroller.ready.direction-horizontal .vue-recycle-scroller__item-view {\n  height: 100%;\n}\n</style>\n","export default function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i&&i.push(e)||n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&i.splice(i.indexOf(e)>>>0,1)},emit:function(t,e){(n.get(t)||[]).slice().map(function(n){n(e)}),(n.get(\"*\")||[]).slice().map(function(n){n(t,e)})}}}\n//# sourceMappingURL=mitt.es.js.map\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<template>\n  <RecycleScroller\n    ref=\"scroller\"\n    :items=\"itemsWithSize\"\n    :min-item-size=\"minItemSize\"\n    :direction=\"direction\"\n    key-field=\"id\"\n    :list-tag=\"listTag\"\n    :item-tag=\"itemTag\"\n    v-bind=\"$attrs\"\n    @resize=\"onScrollerResize\"\n    @visible=\"onScrollerVisible\"\n  >\n    <template #default=\"{ item: itemWithSize, index, active }\">\n      <slot\n        v-bind=\"{\n          item: itemWithSize.item,\n          index,\n          active,\n          itemWithSize\n        }\"\n      />\n    </template>\n    <template #before>\n      <slot name=\"before\" />\n    </template>\n    <template #after>\n      <slot name=\"after\" />\n    </template>\n    <template #empty>\n      <slot name=\"empty\" />\n    </template>\n  </RecycleScroller>\n</template>\n\n<script>\nimport mitt from 'mitt'\nimport RecycleScroller from './RecycleScroller.vue'\nimport { props, simpleArray } from './common'\n\nexport default {\n  name: 'DynamicScroller',\n\n  components: {\n    RecycleScroller,\n  },\n\n  provide () {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.$_resizeObserver = new ResizeObserver(entries => {\n        requestAnimationFrame(() => {\n          if (!Array.isArray(entries)) {\n            return\n          }\n          for (const entry of entries) {\n            if (entry.target && entry.target.$_vs_onResize) {\n              let width, height\n              if (entry.borderBoxSize) {\n                const resizeObserverSize = entry.borderBoxSize[0]\n                width = resizeObserverSize.inlineSize\n                height = resizeObserverSize.blockSize\n              } else {\n                // @TODO remove when contentRect is deprecated\n                width = entry.contentRect.width\n                height = entry.contentRect.height\n              }\n              entry.target.$_vs_onResize(entry.target.$_vs_id, width, height)\n            }\n          }\n        })\n      })\n    }\n\n    return {\n      vscrollData: this.vscrollData,\n      vscrollParent: this,\n      vscrollResizeObserver: this.$_resizeObserver,\n    }\n  },\n\n  inheritAttrs: false,\n\n  props: {\n    ...props,\n\n    minItemSize: {\n      type: [Number, String],\n      required: true,\n    },\n  },\n\n  emits: [\n    'resize',\n    'visible',\n  ],\n\n  data () {\n    return {\n      vscrollData: {\n        active: true,\n        sizes: {},\n        keyField: this.keyField,\n        simpleArray: false,\n      },\n    }\n  },\n\n  computed: {\n    simpleArray,\n\n    itemsWithSize () {\n      const result = []\n      const { items, keyField, simpleArray } = this\n      const sizes = this.vscrollData.sizes\n      const l = items.length\n      for (let i = 0; i < l; i++) {\n        const item = items[i]\n        const id = simpleArray ? i : item[keyField]\n        let size = sizes[id]\n        if (typeof size === 'undefined' && !this.$_undefinedMap[id]) {\n          size = 0\n        }\n        result.push({\n          item,\n          id,\n          size,\n        })\n      }\n      return result\n    },\n  },\n\n  watch: {\n    items () {\n      this.forceUpdate()\n    },\n\n    simpleArray: {\n      handler (value) {\n        this.vscrollData.simpleArray = value\n      },\n      immediate: true,\n    },\n\n    direction (value) {\n      this.forceUpdate(true)\n    },\n\n    itemsWithSize (next, prev) {\n      const scrollTop = this.$el.scrollTop\n\n      // Calculate total diff between prev and next sizes\n      // over current scroll top. Then add it to scrollTop to\n      // avoid jumping the contents that the user is seeing.\n      let prevActiveTop = 0; let activeTop = 0\n      const length = Math.min(next.length, prev.length)\n      for (let i = 0; i < length; i++) {\n        if (prevActiveTop >= scrollTop) {\n          break\n        }\n        prevActiveTop += prev[i].size || this.minItemSize\n        activeTop += next[i].size || this.minItemSize\n      }\n      const offset = activeTop - prevActiveTop\n\n      if (offset === 0) {\n        return\n      }\n\n      this.$el.scrollTop += offset\n    },\n  },\n\n  beforeCreate () {\n    this.$_updates = []\n    this.$_undefinedSizes = 0\n    this.$_undefinedMap = {}\n    this.$_events = mitt()\n  },\n\n  activated () {\n    this.vscrollData.active = true\n  },\n\n  deactivated () {\n    this.vscrollData.active = false\n  },\n\n  unmounted () {\n    this.$_events.all.clear()\n  },\n\n  methods: {\n    onScrollerResize () {\n      const scroller = this.$refs.scroller\n      if (scroller) {\n        this.forceUpdate()\n      }\n      this.$emit('resize')\n    },\n\n    onScrollerVisible () {\n      this.$_events.emit('vscroll:update', { force: false })\n      this.$emit('visible')\n    },\n\n    forceUpdate (clear = false) {\n      if (clear || this.simpleArray) {\n        this.vscrollData.sizes = {}\n      }\n      this.$_events.emit('vscroll:update', { force: true })\n    },\n\n    scrollToItem (index) {\n      const scroller = this.$refs.scroller\n      if (scroller) scroller.scrollToItem(index)\n    },\n\n    getItemSize (item, index = undefined) {\n      const id = this.simpleArray ? (index != null ? index : this.items.indexOf(item)) : item[this.keyField]\n      return this.vscrollData.sizes[id] || 0\n    },\n\n    scrollToBottom () {\n      if (this.$_scrollingToBottom) return\n      this.$_scrollingToBottom = true\n      const el = this.$el\n      // Item is inserted to the DOM\n      this.$nextTick(() => {\n        el.scrollTop = el.scrollHeight + 5000\n        // Item sizes are computed\n        const cb = () => {\n          el.scrollTop = el.scrollHeight + 5000\n          requestAnimationFrame(() => {\n            el.scrollTop = el.scrollHeight + 5000\n            if (this.$_undefinedSizes === 0) {\n              this.$_scrollingToBottom = false\n            } else {\n              requestAnimationFrame(cb)\n            }\n          })\n        }\n        requestAnimationFrame(cb)\n      })\n    },\n  },\n}\n</script>\n","<script>\nimport { h } from 'vue'\n\nexport default {\n  name: 'DynamicScrollerItem',\n\n  inject: [\n    'vscrollData',\n    'vscrollParent',\n    'vscrollResizeObserver',\n  ],\n\n  props: {\n    // eslint-disable-next-line vue/require-prop-types\n    item: {\n      required: true,\n    },\n\n    watchData: {\n      type: Boolean,\n      default: false,\n    },\n\n    /**\n     * Indicates if the view is actively used to display an item.\n     */\n    active: {\n      type: Boolean,\n      required: true,\n    },\n\n    index: {\n      type: Number,\n      default: undefined,\n    },\n\n    sizeDependencies: {\n      type: [Array, Object],\n      default: null,\n    },\n\n    emitResize: {\n      type: Boolean,\n      default: false,\n    },\n\n    tag: {\n      type: String,\n      default: 'div',\n    },\n  },\n\n  emits: [\n    'resize',\n  ],\n\n  computed: {\n    id () {\n      if (this.vscrollData.simpleArray) return this.index\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.vscrollData.keyField in this.item) return this.item[this.vscrollData.keyField]\n      throw new Error(`keyField '${this.vscrollData.keyField}' not found in your item. You should set a valid keyField prop on your Scroller`)\n    },\n\n    size () {\n      return this.vscrollData.sizes[this.id] || 0\n    },\n\n    finalActive () {\n      return this.active && this.vscrollData.active\n    },\n  },\n\n  watch: {\n    watchData: 'updateWatchData',\n\n    id (value, oldValue) {\n      this.$el.$_vs_id = this.id\n      if (!this.size) {\n        this.onDataUpdate()\n      }\n\n      if (this.$_sizeObserved) {\n        // In case the old item had the same size, it won't trigger the ResizeObserver\n        // since we are reusing the same DOM node\n        const oldSize = this.vscrollData.sizes[oldValue]\n        const size = this.vscrollData.sizes[value]\n        if (oldSize != null && oldSize !== size) {\n          this.applySize(oldSize)\n        }\n      }\n    },\n\n    finalActive (value) {\n      if (!this.size) {\n        if (value) {\n          if (!this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes++\n            this.vscrollParent.$_undefinedMap[this.id] = true\n          }\n        } else {\n          if (this.vscrollParent.$_undefinedMap[this.id]) {\n            this.vscrollParent.$_undefinedSizes--\n            this.vscrollParent.$_undefinedMap[this.id] = false\n          }\n        }\n      }\n\n      if (this.vscrollResizeObserver) {\n        if (value) {\n          this.observeSize()\n        } else {\n          this.unobserveSize()\n        }\n      } else if (value && this.$_pendingVScrollUpdate === this.id) {\n        this.updateSize()\n      }\n    },\n  },\n\n  created () {\n    if (this.$isServer) return\n\n    this.$_forceNextVScrollUpdate = null\n    this.updateWatchData()\n\n    if (!this.vscrollResizeObserver) {\n      for (const k in this.sizeDependencies) {\n        this.$watch(() => this.sizeDependencies[k], this.onDataUpdate)\n      }\n\n      this.vscrollParent.$_events.on('vscroll:update', this.onVscrollUpdate)\n    }\n  },\n\n  mounted () {\n    if (this.finalActive) {\n      this.updateSize()\n      this.observeSize()\n    }\n  },\n\n  beforeUnmount () {\n    this.vscrollParent.$_events.off('vscroll:update', this.onVscrollUpdate)\n    this.unobserveSize()\n  },\n\n  methods: {\n    updateSize () {\n      if (this.finalActive) {\n        if (this.$_pendingSizeUpdate !== this.id) {\n          this.$_pendingSizeUpdate = this.id\n          this.$_forceNextVScrollUpdate = null\n          this.$_pendingVScrollUpdate = null\n          this.computeSize(this.id)\n        }\n      } else {\n        this.$_forceNextVScrollUpdate = this.id\n      }\n    },\n\n    updateWatchData () {\n      if (this.watchData && !this.vscrollResizeObserver) {\n        this.$_watchData = this.$watch('item', () => {\n          this.onDataUpdate()\n        }, {\n          deep: true,\n        })\n      } else if (this.$_watchData) {\n        this.$_watchData()\n        this.$_watchData = null\n      }\n    },\n\n    onVscrollUpdate ({ force }) {\n      // If not active, sechedule a size update when it becomes active\n      if (!this.finalActive && force) {\n        this.$_pendingVScrollUpdate = this.id\n      }\n\n      if (this.$_forceNextVScrollUpdate === this.id || force || !this.size) {\n        this.updateSize()\n      }\n    },\n\n    onDataUpdate () {\n      this.updateSize()\n    },\n\n    computeSize (id) {\n      this.$nextTick(() => {\n        if (this.id === id) {\n          const width = this.$el.offsetWidth\n          const height = this.$el.offsetHeight\n          this.applyWidthHeight(width, height)\n        }\n        this.$_pendingSizeUpdate = null\n      })\n    },\n\n    applyWidthHeight (width, height) {\n      const size = ~~(this.vscrollParent.direction === 'vertical' ? height : width)\n      if (size && this.size !== size) {\n        this.applySize(size)\n      }\n    },\n\n    applySize (size) {\n      if (this.vscrollParent.$_undefinedMap[this.id]) {\n        this.vscrollParent.$_undefinedSizes--\n        this.vscrollParent.$_undefinedMap[this.id] = undefined\n      }\n      this.vscrollData.sizes[this.id] = size\n      if (this.emitResize) this.$emit('resize', this.id)\n    },\n\n    observeSize () {\n      if (!this.vscrollResizeObserver) return\n      if (this.$_sizeObserved) return\n      this.vscrollResizeObserver.observe(this.$el)\n      this.$el.$_vs_id = this.id\n      this.$el.$_vs_onResize = this.onResize\n      this.$_sizeObserved = true\n    },\n\n    unobserveSize () {\n      if (!this.vscrollResizeObserver) return\n      if (!this.$_sizeObserved) return\n      this.vscrollResizeObserver.unobserve(this.$el)\n      this.$el.$_vs_onResize = undefined\n      this.$_sizeObserved = false\n    },\n\n    onResize (id, width, height) {\n      if (this.id === id) {\n        this.applyWidthHeight(width, height)\n      }\n    },\n  },\n\n  render () {\n    return h(this.tag, this.$slots.default())\n  },\n}\n</script>\n","import { reactive } from 'vue'\n\nexport default function ({\n  idProp = vm => vm.item.id,\n} = {}) {\n  const store = reactive({})\n\n  // @vue/component\n  return {\n    data () {\n      return {\n        idState: null,\n      }\n    },\n\n    created () {\n      this.$_id = null\n      if (typeof idProp === 'function') {\n        this.$_getId = () => idProp.call(this, this)\n      } else {\n        this.$_getId = () => this[idProp]\n      }\n      this.$watch(this.$_getId, {\n        handler (value) {\n          this.$nextTick(() => {\n            this.$_id = value\n          })\n        },\n        immediate: true,\n      })\n      this.$_updateIdState()\n    },\n\n    beforeUpdate () {\n      this.$_updateIdState()\n    },\n\n    methods: {\n      /**\n       * Initialize an idState\n       * @param {number|string} id Unique id for the data\n       */\n      $_idStateInit (id) {\n        const factory = this.$options.idState\n        if (typeof factory === 'function') {\n          const data = factory.call(this, this)\n          store[id] = data\n          this.$_id = id\n          return data\n        } else {\n          throw new Error('[mixin IdState] Missing `idState` function on component definition.')\n        }\n      },\n\n      /**\n       * Ensure idState is created and up-to-date\n       */\n      $_updateIdState () {\n        const id = this.$_getId()\n        if (id == null) {\n          console.warn(`No id found for IdState with idProp: '${idProp}'.`)\n        }\n        if (id !== this.$_id) {\n          if (!store[id]) {\n            this.$_idStateInit(id)\n          }\n          this.idState = store[id]\n        }\n      },\n    },\n  }\n}\n","import config from './config'\n\nimport RecycleScroller from './components/RecycleScroller.vue'\nimport DynamicScroller from './components/DynamicScroller.vue'\nimport DynamicScrollerItem from './components/DynamicScrollerItem.vue'\n\nexport { default as IdState } from './mixins/IdState'\n\nexport {\n  RecycleScroller,\n  DynamicScroller,\n  DynamicScrollerItem,\n}\n\nfunction registerComponents (app, prefix) {\n  app.component(`${prefix}recycle-scroller`, RecycleScroller)\n  app.component(`${prefix}RecycleScroller`, RecycleScroller)\n  app.component(`${prefix}dynamic-scroller`, DynamicScroller)\n  app.component(`${prefix}DynamicScroller`, DynamicScroller)\n  app.component(`${prefix}dynamic-scroller-item`, DynamicScrollerItem)\n  app.component(`${prefix}DynamicScrollerItem`, DynamicScrollerItem)\n}\n\nconst plugin = {\n  // eslint-disable-next-line no-undef\n  version: VERSION,\n  install (app, options) {\n    const finalOptions = Object.assign({}, {\n      installComponents: true,\n      componentsPrefix: '',\n    }, options)\n\n    for (const key in finalOptions) {\n      if (typeof finalOptions[key] !== 'undefined') {\n        config[key] = finalOptions[key]\n      }\n    }\n\n    if (finalOptions.installComponents) {\n      registerComponents(app, finalOptions.componentsPrefix)\n    }\n  },\n}\n\nexport default plugin\n"],"names":["itemsLimit","getInternetExplorerVersion","ua","window","navigator","userAgent","msie","indexOf","parseInt","substring","trident","rv","edge","_typeof","obj","Symbol","iterator","constructor","prototype","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","_createClass","protoProps","staticProps","_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","Array","isArray","_arrayLikeToArray","iter","from","o","minLen","n","toString","call","slice","name","test","len","arr2","processOptions","value","options","callback","throttle","delay","arguments","undefined","timeout","lastState","currentArgs","throttled","state","_len","args","_key","leading","apply","concat","clearTimeout","setTimeout","_clear","deepEqual","val1","val2","VisibilityState","el","vnode","observer","frozen","createObserver","_this","destroyObserver","result","entry","once","_ref","throttleOptions","_leading","oldResult","IntersectionObserver","entries","intersectingEntry","find","e","isIntersecting","intersectionRatio","threshold","intersection","nextTick","observe","disconnect","get","beforeMount","_ref2","console","warn","_vue_visibilityState","updated","_ref3","oldValue","unmounted","ObserveVisibility","regex","parents","node","ps","parentNode","style","prop","getComputedStyle","getPropertyValue","overflow","scroll","getScrollParent","HTMLElement","SVGElement","document","scrollingElement","documentElement","items","type","required","keyField","String","default","direction","validator","includes","listTag","itemTag","simpleArray","supportsPassive","opts","addEventListener","ResizeObserver","markRaw","shallowReactive","_createElementBlock","_openBlock","_renderSlot","_createBlock","_resolveDynamicComponent","_normalizeStyle","_normalizeClass","_Fragment","_renderList","_mergeProps","_toHandlers","_createVNode","all","Map","on","handler","handlers","push","set","off","splice","emit","evt","map","RecycleScroller","_normalizeProps","_guardReactiveProps","h","idProp","vm","item","id","store","reactive","data","idState","created","$_id","$_getId","$watch","$nextTick","immediate","$_updateIdState","beforeUpdate","methods","$_idStateInit","factory","$options","Error","registerComponents","app","prefix","component","DynamicScroller","DynamicScrollerItem","plugin","version","VERSION","install","finalOptions","assign","installComponents","componentsPrefix","config"],"mappings":"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"}
\ No newline at end of file
